// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `common/stream.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct DataflowMeta {
    // message fields
    pub center: u32,
    pub neighbors: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataflowMeta {
    fn default() -> &'a DataflowMeta {
        <DataflowMeta as ::protobuf::Message>::default_instance()
    }
}

impl DataflowMeta {
    pub fn new() -> DataflowMeta {
        ::std::default::Default::default()
    }

    // uint32 center = 1;


    pub fn get_center(&self) -> u32 {
        self.center
    }
    pub fn clear_center(&mut self) {
        self.center = 0;
    }

    // Param is passed by value, moved
    pub fn set_center(&mut self, v: u32) {
        self.center = v;
    }

    // repeated uint32 neighbors = 2;


    pub fn get_neighbors(&self) -> &[u32] {
        &self.neighbors
    }
    pub fn clear_neighbors(&mut self) {
        self.neighbors.clear();
    }

    // Param is passed by value, moved
    pub fn set_neighbors(&mut self, v: ::std::vec::Vec<u32>) {
        self.neighbors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_neighbors(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.neighbors
    }

    // Take field
    pub fn take_neighbors(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.neighbors, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DataflowMeta {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.center = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.neighbors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.center != 0 {
            my_size += ::protobuf::rt::value_size(1, self.center, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.neighbors {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.center != 0 {
            os.write_uint32(1, self.center)?;
        }
        for v in &self.neighbors {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataflowMeta {
        DataflowMeta::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "center",
                |m: &DataflowMeta| { &m.center },
                |m: &mut DataflowMeta| { &mut m.center },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "neighbors",
                |m: &DataflowMeta| { &m.neighbors },
                |m: &mut DataflowMeta| { &mut m.neighbors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataflowMeta>(
                "DataflowMeta",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataflowMeta {
        static instance: ::protobuf::rt::LazyV2<DataflowMeta> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataflowMeta::new)
    }
}

impl ::protobuf::Clear for DataflowMeta {
    fn clear(&mut self) {
        self.center = 0;
        self.neighbors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataflowMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataflowMeta {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperatorInfo {
    // message fields
    pub operator_id: u32,
    pub host_addr: ::protobuf::SingularPtrField<super::common::HostAddr>,
    pub config: ::protobuf::SingularPtrField<StreamConfig>,
    pub upstreams: ::std::vec::Vec<u32>,
    // message oneof groups
    pub details: ::std::option::Option<OperatorInfo_oneof_details>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OperatorInfo {
    fn default() -> &'a OperatorInfo {
        <OperatorInfo as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum OperatorInfo_oneof_details {
    source(Source),
    sink(Sink),
    mapper(Mapper),
    filter(Filter),
    key_by(KeyBy),
    reducer(Reducer),
    flat_map(FlatMap),
}

impl OperatorInfo {
    pub fn new() -> OperatorInfo {
        ::std::default::Default::default()
    }

    // uint32 operator_id = 1;


    pub fn get_operator_id(&self) -> u32 {
        self.operator_id
    }
    pub fn clear_operator_id(&mut self) {
        self.operator_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_operator_id(&mut self, v: u32) {
        self.operator_id = v;
    }

    // .common.HostAddr host_addr = 2;


    pub fn get_host_addr(&self) -> &super::common::HostAddr {
        self.host_addr.as_ref().unwrap_or_else(|| <super::common::HostAddr as ::protobuf::Message>::default_instance())
    }
    pub fn clear_host_addr(&mut self) {
        self.host_addr.clear();
    }

    pub fn has_host_addr(&self) -> bool {
        self.host_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_addr(&mut self, v: super::common::HostAddr) {
        self.host_addr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_addr(&mut self) -> &mut super::common::HostAddr {
        if self.host_addr.is_none() {
            self.host_addr.set_default();
        }
        self.host_addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_addr(&mut self) -> super::common::HostAddr {
        self.host_addr.take().unwrap_or_else(|| super::common::HostAddr::new())
    }

    // .common.StreamConfig config = 3;


    pub fn get_config(&self) -> &StreamConfig {
        self.config.as_ref().unwrap_or_else(|| <StreamConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: StreamConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut StreamConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> StreamConfig {
        self.config.take().unwrap_or_else(|| StreamConfig::new())
    }

    // repeated uint32 upstreams = 4;


    pub fn get_upstreams(&self) -> &[u32] {
        &self.upstreams
    }
    pub fn clear_upstreams(&mut self) {
        self.upstreams.clear();
    }

    // Param is passed by value, moved
    pub fn set_upstreams(&mut self, v: ::std::vec::Vec<u32>) {
        self.upstreams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_upstreams(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.upstreams
    }

    // Take field
    pub fn take_upstreams(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.upstreams, ::std::vec::Vec::new())
    }

    // .common.Source source = 5;


    pub fn get_source(&self) -> &Source {
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::source(ref v)) => v,
            _ => <Source as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_source(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_source(&self) -> bool {
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::source(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Source) {
        self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::source(v))
    }

    // Mutable pointer to the field.
    pub fn mut_source(&mut self) -> &mut Source {
        if let ::std::option::Option::Some(OperatorInfo_oneof_details::source(_)) = self.details {
        } else {
            self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::source(Source::new()));
        }
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::source(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_source(&mut self) -> Source {
        if self.has_source() {
            match self.details.take() {
                ::std::option::Option::Some(OperatorInfo_oneof_details::source(v)) => v,
                _ => panic!(),
            }
        } else {
            Source::new()
        }
    }

    // .common.Sink sink = 6;


    pub fn get_sink(&self) -> &Sink {
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::sink(ref v)) => v,
            _ => <Sink as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_sink(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_sink(&self) -> bool {
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::sink(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sink(&mut self, v: Sink) {
        self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::sink(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sink(&mut self) -> &mut Sink {
        if let ::std::option::Option::Some(OperatorInfo_oneof_details::sink(_)) = self.details {
        } else {
            self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::sink(Sink::new()));
        }
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::sink(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sink(&mut self) -> Sink {
        if self.has_sink() {
            match self.details.take() {
                ::std::option::Option::Some(OperatorInfo_oneof_details::sink(v)) => v,
                _ => panic!(),
            }
        } else {
            Sink::new()
        }
    }

    // .common.Mapper mapper = 7;


    pub fn get_mapper(&self) -> &Mapper {
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::mapper(ref v)) => v,
            _ => <Mapper as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_mapper(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_mapper(&self) -> bool {
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::mapper(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mapper(&mut self, v: Mapper) {
        self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::mapper(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mapper(&mut self) -> &mut Mapper {
        if let ::std::option::Option::Some(OperatorInfo_oneof_details::mapper(_)) = self.details {
        } else {
            self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::mapper(Mapper::new()));
        }
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::mapper(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mapper(&mut self) -> Mapper {
        if self.has_mapper() {
            match self.details.take() {
                ::std::option::Option::Some(OperatorInfo_oneof_details::mapper(v)) => v,
                _ => panic!(),
            }
        } else {
            Mapper::new()
        }
    }

    // .common.Filter filter = 8;


    pub fn get_filter(&self) -> &Filter {
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::filter(ref v)) => v,
            _ => <Filter as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_filter(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_filter(&self) -> bool {
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: Filter) {
        self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_filter(&mut self) -> &mut Filter {
        if let ::std::option::Option::Some(OperatorInfo_oneof_details::filter(_)) = self.details {
        } else {
            self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::filter(Filter::new()));
        }
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_filter(&mut self) -> Filter {
        if self.has_filter() {
            match self.details.take() {
                ::std::option::Option::Some(OperatorInfo_oneof_details::filter(v)) => v,
                _ => panic!(),
            }
        } else {
            Filter::new()
        }
    }

    // .common.KeyBy key_by = 9;


    pub fn get_key_by(&self) -> &KeyBy {
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::key_by(ref v)) => v,
            _ => <KeyBy as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_key_by(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_key_by(&self) -> bool {
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::key_by(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_key_by(&mut self, v: KeyBy) {
        self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::key_by(v))
    }

    // Mutable pointer to the field.
    pub fn mut_key_by(&mut self) -> &mut KeyBy {
        if let ::std::option::Option::Some(OperatorInfo_oneof_details::key_by(_)) = self.details {
        } else {
            self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::key_by(KeyBy::new()));
        }
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::key_by(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_key_by(&mut self) -> KeyBy {
        if self.has_key_by() {
            match self.details.take() {
                ::std::option::Option::Some(OperatorInfo_oneof_details::key_by(v)) => v,
                _ => panic!(),
            }
        } else {
            KeyBy::new()
        }
    }

    // .common.Reducer reducer = 10;


    pub fn get_reducer(&self) -> &Reducer {
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::reducer(ref v)) => v,
            _ => <Reducer as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_reducer(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_reducer(&self) -> bool {
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::reducer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reducer(&mut self, v: Reducer) {
        self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::reducer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reducer(&mut self) -> &mut Reducer {
        if let ::std::option::Option::Some(OperatorInfo_oneof_details::reducer(_)) = self.details {
        } else {
            self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::reducer(Reducer::new()));
        }
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::reducer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reducer(&mut self) -> Reducer {
        if self.has_reducer() {
            match self.details.take() {
                ::std::option::Option::Some(OperatorInfo_oneof_details::reducer(v)) => v,
                _ => panic!(),
            }
        } else {
            Reducer::new()
        }
    }

    // .common.FlatMap flat_map = 11;


    pub fn get_flat_map(&self) -> &FlatMap {
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::flat_map(ref v)) => v,
            _ => <FlatMap as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_flat_map(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_flat_map(&self) -> bool {
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::flat_map(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_flat_map(&mut self, v: FlatMap) {
        self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::flat_map(v))
    }

    // Mutable pointer to the field.
    pub fn mut_flat_map(&mut self) -> &mut FlatMap {
        if let ::std::option::Option::Some(OperatorInfo_oneof_details::flat_map(_)) = self.details {
        } else {
            self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::flat_map(FlatMap::new()));
        }
        match self.details {
            ::std::option::Option::Some(OperatorInfo_oneof_details::flat_map(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_flat_map(&mut self) -> FlatMap {
        if self.has_flat_map() {
            match self.details.take() {
                ::std::option::Option::Some(OperatorInfo_oneof_details::flat_map(v)) => v,
                _ => panic!(),
            }
        } else {
            FlatMap::new()
        }
    }
}

impl ::protobuf::Message for OperatorInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.host_addr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(OperatorInfo_oneof_details::source(ref v)) = self.details {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OperatorInfo_oneof_details::sink(ref v)) = self.details {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OperatorInfo_oneof_details::mapper(ref v)) = self.details {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OperatorInfo_oneof_details::filter(ref v)) = self.details {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OperatorInfo_oneof_details::key_by(ref v)) = self.details {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OperatorInfo_oneof_details::reducer(ref v)) = self.details {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OperatorInfo_oneof_details::flat_map(ref v)) = self.details {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.operator_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.host_addr)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.upstreams)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::source(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::sink(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::mapper(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::filter(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::key_by(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::reducer(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.details = ::std::option::Option::Some(OperatorInfo_oneof_details::flat_map(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.operator_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.operator_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.host_addr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.upstreams {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let ::std::option::Option::Some(ref v) = self.details {
            match v {
                &OperatorInfo_oneof_details::source(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OperatorInfo_oneof_details::sink(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OperatorInfo_oneof_details::mapper(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OperatorInfo_oneof_details::filter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OperatorInfo_oneof_details::key_by(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OperatorInfo_oneof_details::reducer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OperatorInfo_oneof_details::flat_map(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.operator_id != 0 {
            os.write_uint32(1, self.operator_id)?;
        }
        if let Some(ref v) = self.host_addr.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.upstreams {
            os.write_uint32(4, *v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.details {
            match v {
                &OperatorInfo_oneof_details::source(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OperatorInfo_oneof_details::sink(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OperatorInfo_oneof_details::mapper(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OperatorInfo_oneof_details::filter(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OperatorInfo_oneof_details::key_by(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OperatorInfo_oneof_details::reducer(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OperatorInfo_oneof_details::flat_map(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperatorInfo {
        OperatorInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "operator_id",
                |m: &OperatorInfo| { &m.operator_id },
                |m: &mut OperatorInfo| { &mut m.operator_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::HostAddr>>(
                "host_addr",
                |m: &OperatorInfo| { &m.host_addr },
                |m: &mut OperatorInfo| { &mut m.host_addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StreamConfig>>(
                "config",
                |m: &OperatorInfo| { &m.config },
                |m: &mut OperatorInfo| { &mut m.config },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "upstreams",
                |m: &OperatorInfo| { &m.upstreams },
                |m: &mut OperatorInfo| { &mut m.upstreams },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Source>(
                "source",
                OperatorInfo::has_source,
                OperatorInfo::get_source,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Sink>(
                "sink",
                OperatorInfo::has_sink,
                OperatorInfo::get_sink,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Mapper>(
                "mapper",
                OperatorInfo::has_mapper,
                OperatorInfo::get_mapper,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Filter>(
                "filter",
                OperatorInfo::has_filter,
                OperatorInfo::get_filter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, KeyBy>(
                "key_by",
                OperatorInfo::has_key_by,
                OperatorInfo::get_key_by,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Reducer>(
                "reducer",
                OperatorInfo::has_reducer,
                OperatorInfo::get_reducer,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FlatMap>(
                "flat_map",
                OperatorInfo::has_flat_map,
                OperatorInfo::get_flat_map,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OperatorInfo>(
                "OperatorInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OperatorInfo {
        static instance: ::protobuf::rt::LazyV2<OperatorInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OperatorInfo::new)
    }
}

impl ::protobuf::Clear for OperatorInfo {
    fn clear(&mut self) {
        self.operator_id = 0;
        self.host_addr.clear();
        self.config.clear();
        self.upstreams.clear();
        self.details = ::std::option::Option::None;
        self.details = ::std::option::Option::None;
        self.details = ::std::option::Option::None;
        self.details = ::std::option::Option::None;
        self.details = ::std::option::Option::None;
        self.details = ::std::option::Option::None;
        self.details = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperatorInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperatorInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Reducer {
    // message oneof groups
    pub value: ::std::option::Option<Reducer_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Reducer {
    fn default() -> &'a Reducer {
        <Reducer as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Reducer_oneof_value {
    func(Func),
}

impl Reducer {
    pub fn new() -> Reducer {
        ::std::default::Default::default()
    }

    // .common.Func func = 1;


    pub fn get_func(&self) -> &Func {
        match self.value {
            ::std::option::Option::Some(Reducer_oneof_value::func(ref v)) => v,
            _ => <Func as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_func(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_func(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Reducer_oneof_value::func(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_func(&mut self, v: Func) {
        self.value = ::std::option::Option::Some(Reducer_oneof_value::func(v))
    }

    // Mutable pointer to the field.
    pub fn mut_func(&mut self) -> &mut Func {
        if let ::std::option::Option::Some(Reducer_oneof_value::func(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Reducer_oneof_value::func(Func::new()));
        }
        match self.value {
            ::std::option::Option::Some(Reducer_oneof_value::func(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_func(&mut self) -> Func {
        if self.has_func() {
            match self.value.take() {
                ::std::option::Option::Some(Reducer_oneof_value::func(v)) => v,
                _ => panic!(),
            }
        } else {
            Func::new()
        }
    }
}

impl ::protobuf::Message for Reducer {
    fn is_initialized(&self) -> bool {
        if let Some(Reducer_oneof_value::func(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Reducer_oneof_value::func(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Reducer_oneof_value::func(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Reducer_oneof_value::func(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Reducer {
        Reducer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Func>(
                "func",
                Reducer::has_func,
                Reducer::get_func,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Reducer>(
                "Reducer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Reducer {
        static instance: ::protobuf::rt::LazyV2<Reducer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Reducer::new)
    }
}

impl ::protobuf::Clear for Reducer {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Reducer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Reducer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlatMap {
    // message oneof groups
    pub value: ::std::option::Option<FlatMap_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlatMap {
    fn default() -> &'a FlatMap {
        <FlatMap as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum FlatMap_oneof_value {
    func(Func),
}

impl FlatMap {
    pub fn new() -> FlatMap {
        ::std::default::Default::default()
    }

    // .common.Func func = 1;


    pub fn get_func(&self) -> &Func {
        match self.value {
            ::std::option::Option::Some(FlatMap_oneof_value::func(ref v)) => v,
            _ => <Func as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_func(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_func(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(FlatMap_oneof_value::func(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_func(&mut self, v: Func) {
        self.value = ::std::option::Option::Some(FlatMap_oneof_value::func(v))
    }

    // Mutable pointer to the field.
    pub fn mut_func(&mut self) -> &mut Func {
        if let ::std::option::Option::Some(FlatMap_oneof_value::func(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(FlatMap_oneof_value::func(Func::new()));
        }
        match self.value {
            ::std::option::Option::Some(FlatMap_oneof_value::func(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_func(&mut self) -> Func {
        if self.has_func() {
            match self.value.take() {
                ::std::option::Option::Some(FlatMap_oneof_value::func(v)) => v,
                _ => panic!(),
            }
        } else {
            Func::new()
        }
    }
}

impl ::protobuf::Message for FlatMap {
    fn is_initialized(&self) -> bool {
        if let Some(FlatMap_oneof_value::func(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(FlatMap_oneof_value::func(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &FlatMap_oneof_value::func(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &FlatMap_oneof_value::func(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlatMap {
        FlatMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Func>(
                "func",
                FlatMap::has_func,
                FlatMap::get_func,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FlatMap>(
                "FlatMap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FlatMap {
        static instance: ::protobuf::rt::LazyV2<FlatMap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FlatMap::new)
    }
}

impl ::protobuf::Clear for FlatMap {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlatMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlatMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Join {
    // message oneof groups
    pub value: ::std::option::Option<Join_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Join {
    fn default() -> &'a Join {
        <Join as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Join_oneof_value {
    stream_join(Join_StreamJoin),
}

impl Join {
    pub fn new() -> Join {
        ::std::default::Default::default()
    }

    // .common.Join.StreamJoin stream_join = 1;


    pub fn get_stream_join(&self) -> &Join_StreamJoin {
        match self.value {
            ::std::option::Option::Some(Join_oneof_value::stream_join(ref v)) => v,
            _ => <Join_StreamJoin as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_stream_join(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_stream_join(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Join_oneof_value::stream_join(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stream_join(&mut self, v: Join_StreamJoin) {
        self.value = ::std::option::Option::Some(Join_oneof_value::stream_join(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stream_join(&mut self) -> &mut Join_StreamJoin {
        if let ::std::option::Option::Some(Join_oneof_value::stream_join(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Join_oneof_value::stream_join(Join_StreamJoin::new()));
        }
        match self.value {
            ::std::option::Option::Some(Join_oneof_value::stream_join(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stream_join(&mut self) -> Join_StreamJoin {
        if self.has_stream_join() {
            match self.value.take() {
                ::std::option::Option::Some(Join_oneof_value::stream_join(v)) => v,
                _ => panic!(),
            }
        } else {
            Join_StreamJoin::new()
        }
    }
}

impl ::protobuf::Message for Join {
    fn is_initialized(&self) -> bool {
        if let Some(Join_oneof_value::stream_join(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Join_oneof_value::stream_join(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Join_oneof_value::stream_join(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Join_oneof_value::stream_join(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Join {
        Join::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Join_StreamJoin>(
                "stream_join",
                Join::has_stream_join,
                Join::get_stream_join,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Join>(
                "Join",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Join {
        static instance: ::protobuf::rt::LazyV2<Join> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Join::new)
    }
}

impl ::protobuf::Clear for Join {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Join {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Join {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Join_StreamJoin {
    // message fields
    pub operator_id: u32,
    pub func: ::protobuf::SingularPtrField<Func>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Join_StreamJoin {
    fn default() -> &'a Join_StreamJoin {
        <Join_StreamJoin as ::protobuf::Message>::default_instance()
    }
}

impl Join_StreamJoin {
    pub fn new() -> Join_StreamJoin {
        ::std::default::Default::default()
    }

    // uint32 operator_id = 1;


    pub fn get_operator_id(&self) -> u32 {
        self.operator_id
    }
    pub fn clear_operator_id(&mut self) {
        self.operator_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_operator_id(&mut self, v: u32) {
        self.operator_id = v;
    }

    // .common.Func func = 2;


    pub fn get_func(&self) -> &Func {
        self.func.as_ref().unwrap_or_else(|| <Func as ::protobuf::Message>::default_instance())
    }
    pub fn clear_func(&mut self) {
        self.func.clear();
    }

    pub fn has_func(&self) -> bool {
        self.func.is_some()
    }

    // Param is passed by value, moved
    pub fn set_func(&mut self, v: Func) {
        self.func = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_func(&mut self) -> &mut Func {
        if self.func.is_none() {
            self.func.set_default();
        }
        self.func.as_mut().unwrap()
    }

    // Take field
    pub fn take_func(&mut self) -> Func {
        self.func.take().unwrap_or_else(|| Func::new())
    }
}

impl ::protobuf::Message for Join_StreamJoin {
    fn is_initialized(&self) -> bool {
        for v in &self.func {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.operator_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.func)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.operator_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.operator_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.func.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.operator_id != 0 {
            os.write_uint32(1, self.operator_id)?;
        }
        if let Some(ref v) = self.func.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Join_StreamJoin {
        Join_StreamJoin::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "operator_id",
                |m: &Join_StreamJoin| { &m.operator_id },
                |m: &mut Join_StreamJoin| { &mut m.operator_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Func>>(
                "func",
                |m: &Join_StreamJoin| { &m.func },
                |m: &mut Join_StreamJoin| { &mut m.func },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Join_StreamJoin>(
                "Join.StreamJoin",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Join_StreamJoin {
        static instance: ::protobuf::rt::LazyV2<Join_StreamJoin> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Join_StreamJoin::new)
    }
}

impl ::protobuf::Clear for Join_StreamJoin {
    fn clear(&mut self) {
        self.operator_id = 0;
        self.func.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Join_StreamJoin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Join_StreamJoin {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Mapper {
    // message oneof groups
    pub value: ::std::option::Option<Mapper_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Mapper {
    fn default() -> &'a Mapper {
        <Mapper as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Mapper_oneof_value {
    func(Func),
}

impl Mapper {
    pub fn new() -> Mapper {
        ::std::default::Default::default()
    }

    // .common.Func func = 1;


    pub fn get_func(&self) -> &Func {
        match self.value {
            ::std::option::Option::Some(Mapper_oneof_value::func(ref v)) => v,
            _ => <Func as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_func(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_func(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Mapper_oneof_value::func(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_func(&mut self, v: Func) {
        self.value = ::std::option::Option::Some(Mapper_oneof_value::func(v))
    }

    // Mutable pointer to the field.
    pub fn mut_func(&mut self) -> &mut Func {
        if let ::std::option::Option::Some(Mapper_oneof_value::func(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Mapper_oneof_value::func(Func::new()));
        }
        match self.value {
            ::std::option::Option::Some(Mapper_oneof_value::func(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_func(&mut self) -> Func {
        if self.has_func() {
            match self.value.take() {
                ::std::option::Option::Some(Mapper_oneof_value::func(v)) => v,
                _ => panic!(),
            }
        } else {
            Func::new()
        }
    }
}

impl ::protobuf::Message for Mapper {
    fn is_initialized(&self) -> bool {
        if let Some(Mapper_oneof_value::func(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Mapper_oneof_value::func(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Mapper_oneof_value::func(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Mapper_oneof_value::func(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Mapper {
        Mapper::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Func>(
                "func",
                Mapper::has_func,
                Mapper::get_func,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Mapper>(
                "Mapper",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Mapper {
        static instance: ::protobuf::rt::LazyV2<Mapper> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Mapper::new)
    }
}

impl ::protobuf::Clear for Mapper {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Mapper {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Mapper {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Func {
    // message fields
    pub function: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Func {
    fn default() -> &'a Func {
        <Func as ::protobuf::Message>::default_instance()
    }
}

impl Func {
    pub fn new() -> Func {
        ::std::default::Default::default()
    }

    // string function = 1;


    pub fn get_function(&self) -> &str {
        &self.function
    }
    pub fn clear_function(&mut self) {
        self.function.clear();
    }

    // Param is passed by value, moved
    pub fn set_function(&mut self, v: ::std::string::String) {
        self.function = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function(&mut self) -> &mut ::std::string::String {
        &mut self.function
    }

    // Take field
    pub fn take_function(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.function, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Func {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.function)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.function.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.function);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.function.is_empty() {
            os.write_string(1, &self.function)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Func {
        Func::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "function",
                |m: &Func| { &m.function },
                |m: &mut Func| { &mut m.function },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Func>(
                "Func",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Func {
        static instance: ::protobuf::rt::LazyV2<Func> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Func::new)
    }
}

impl ::protobuf::Clear for Func {
    fn clear(&mut self) {
        self.function.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Func {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Func {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Filter {
    // message oneof groups
    pub value: ::std::option::Option<Filter_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Filter {
    fn default() -> &'a Filter {
        <Filter as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Filter_oneof_value {
    func(Func),
}

impl Filter {
    pub fn new() -> Filter {
        ::std::default::Default::default()
    }

    // .common.Func func = 1;


    pub fn get_func(&self) -> &Func {
        match self.value {
            ::std::option::Option::Some(Filter_oneof_value::func(ref v)) => v,
            _ => <Func as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_func(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_func(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Filter_oneof_value::func(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_func(&mut self, v: Func) {
        self.value = ::std::option::Option::Some(Filter_oneof_value::func(v))
    }

    // Mutable pointer to the field.
    pub fn mut_func(&mut self) -> &mut Func {
        if let ::std::option::Option::Some(Filter_oneof_value::func(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Filter_oneof_value::func(Func::new()));
        }
        match self.value {
            ::std::option::Option::Some(Filter_oneof_value::func(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_func(&mut self) -> Func {
        if self.has_func() {
            match self.value.take() {
                ::std::option::Option::Some(Filter_oneof_value::func(v)) => v,
                _ => panic!(),
            }
        } else {
            Func::new()
        }
    }
}

impl ::protobuf::Message for Filter {
    fn is_initialized(&self) -> bool {
        if let Some(Filter_oneof_value::func(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Filter_oneof_value::func(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Filter_oneof_value::func(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Filter_oneof_value::func(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Filter {
        Filter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Func>(
                "func",
                Filter::has_func,
                Filter::get_func,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Filter>(
                "Filter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Filter {
        static instance: ::protobuf::rt::LazyV2<Filter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Filter::new)
    }
}

impl ::protobuf::Clear for Filter {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Filter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Filter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyBy {
    // message oneof groups
    pub value: ::std::option::Option<KeyBy_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyBy {
    fn default() -> &'a KeyBy {
        <KeyBy as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum KeyBy_oneof_value {
    func(Func),
}

impl KeyBy {
    pub fn new() -> KeyBy {
        ::std::default::Default::default()
    }

    // .common.Func func = 1;


    pub fn get_func(&self) -> &Func {
        match self.value {
            ::std::option::Option::Some(KeyBy_oneof_value::func(ref v)) => v,
            _ => <Func as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_func(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_func(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(KeyBy_oneof_value::func(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_func(&mut self, v: Func) {
        self.value = ::std::option::Option::Some(KeyBy_oneof_value::func(v))
    }

    // Mutable pointer to the field.
    pub fn mut_func(&mut self) -> &mut Func {
        if let ::std::option::Option::Some(KeyBy_oneof_value::func(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(KeyBy_oneof_value::func(Func::new()));
        }
        match self.value {
            ::std::option::Option::Some(KeyBy_oneof_value::func(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_func(&mut self) -> Func {
        if self.has_func() {
            match self.value.take() {
                ::std::option::Option::Some(KeyBy_oneof_value::func(v)) => v,
                _ => panic!(),
            }
        } else {
            Func::new()
        }
    }
}

impl ::protobuf::Message for KeyBy {
    fn is_initialized(&self) -> bool {
        if let Some(KeyBy_oneof_value::func(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(KeyBy_oneof_value::func(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &KeyBy_oneof_value::func(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &KeyBy_oneof_value::func(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyBy {
        KeyBy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Func>(
                "func",
                KeyBy::has_func,
                KeyBy::get_func,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyBy>(
                "KeyBy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyBy {
        static instance: ::protobuf::rt::LazyV2<KeyBy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyBy::new)
    }
}

impl ::protobuf::Clear for KeyBy {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyBy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyBy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Sink {
    // message oneof groups
    pub desc: ::std::option::Option<Sink_oneof_desc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Sink {
    fn default() -> &'a Sink {
        <Sink as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Sink_oneof_desc {
    kafka(KafkaDesc),
    mysql(MysqlDesc),
    redis(RedisDesc),
}

impl Sink {
    pub fn new() -> Sink {
        ::std::default::Default::default()
    }

    // .common.KafkaDesc kafka = 1;


    pub fn get_kafka(&self) -> &KafkaDesc {
        match self.desc {
            ::std::option::Option::Some(Sink_oneof_desc::kafka(ref v)) => v,
            _ => <KafkaDesc as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_kafka(&mut self) {
        self.desc = ::std::option::Option::None;
    }

    pub fn has_kafka(&self) -> bool {
        match self.desc {
            ::std::option::Option::Some(Sink_oneof_desc::kafka(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_kafka(&mut self, v: KafkaDesc) {
        self.desc = ::std::option::Option::Some(Sink_oneof_desc::kafka(v))
    }

    // Mutable pointer to the field.
    pub fn mut_kafka(&mut self) -> &mut KafkaDesc {
        if let ::std::option::Option::Some(Sink_oneof_desc::kafka(_)) = self.desc {
        } else {
            self.desc = ::std::option::Option::Some(Sink_oneof_desc::kafka(KafkaDesc::new()));
        }
        match self.desc {
            ::std::option::Option::Some(Sink_oneof_desc::kafka(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_kafka(&mut self) -> KafkaDesc {
        if self.has_kafka() {
            match self.desc.take() {
                ::std::option::Option::Some(Sink_oneof_desc::kafka(v)) => v,
                _ => panic!(),
            }
        } else {
            KafkaDesc::new()
        }
    }

    // .common.MysqlDesc mysql = 2;


    pub fn get_mysql(&self) -> &MysqlDesc {
        match self.desc {
            ::std::option::Option::Some(Sink_oneof_desc::mysql(ref v)) => v,
            _ => <MysqlDesc as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_mysql(&mut self) {
        self.desc = ::std::option::Option::None;
    }

    pub fn has_mysql(&self) -> bool {
        match self.desc {
            ::std::option::Option::Some(Sink_oneof_desc::mysql(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mysql(&mut self, v: MysqlDesc) {
        self.desc = ::std::option::Option::Some(Sink_oneof_desc::mysql(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mysql(&mut self) -> &mut MysqlDesc {
        if let ::std::option::Option::Some(Sink_oneof_desc::mysql(_)) = self.desc {
        } else {
            self.desc = ::std::option::Option::Some(Sink_oneof_desc::mysql(MysqlDesc::new()));
        }
        match self.desc {
            ::std::option::Option::Some(Sink_oneof_desc::mysql(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mysql(&mut self) -> MysqlDesc {
        if self.has_mysql() {
            match self.desc.take() {
                ::std::option::Option::Some(Sink_oneof_desc::mysql(v)) => v,
                _ => panic!(),
            }
        } else {
            MysqlDesc::new()
        }
    }

    // .common.RedisDesc redis = 3;


    pub fn get_redis(&self) -> &RedisDesc {
        match self.desc {
            ::std::option::Option::Some(Sink_oneof_desc::redis(ref v)) => v,
            _ => <RedisDesc as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_redis(&mut self) {
        self.desc = ::std::option::Option::None;
    }

    pub fn has_redis(&self) -> bool {
        match self.desc {
            ::std::option::Option::Some(Sink_oneof_desc::redis(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_redis(&mut self, v: RedisDesc) {
        self.desc = ::std::option::Option::Some(Sink_oneof_desc::redis(v))
    }

    // Mutable pointer to the field.
    pub fn mut_redis(&mut self) -> &mut RedisDesc {
        if let ::std::option::Option::Some(Sink_oneof_desc::redis(_)) = self.desc {
        } else {
            self.desc = ::std::option::Option::Some(Sink_oneof_desc::redis(RedisDesc::new()));
        }
        match self.desc {
            ::std::option::Option::Some(Sink_oneof_desc::redis(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_redis(&mut self) -> RedisDesc {
        if self.has_redis() {
            match self.desc.take() {
                ::std::option::Option::Some(Sink_oneof_desc::redis(v)) => v,
                _ => panic!(),
            }
        } else {
            RedisDesc::new()
        }
    }
}

impl ::protobuf::Message for Sink {
    fn is_initialized(&self) -> bool {
        if let Some(Sink_oneof_desc::kafka(ref v)) = self.desc {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Sink_oneof_desc::mysql(ref v)) = self.desc {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Sink_oneof_desc::redis(ref v)) = self.desc {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.desc = ::std::option::Option::Some(Sink_oneof_desc::kafka(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.desc = ::std::option::Option::Some(Sink_oneof_desc::mysql(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.desc = ::std::option::Option::Some(Sink_oneof_desc::redis(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.desc {
            match v {
                &Sink_oneof_desc::kafka(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Sink_oneof_desc::mysql(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Sink_oneof_desc::redis(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.desc {
            match v {
                &Sink_oneof_desc::kafka(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Sink_oneof_desc::mysql(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Sink_oneof_desc::redis(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Sink {
        Sink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, KafkaDesc>(
                "kafka",
                Sink::has_kafka,
                Sink::get_kafka,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MysqlDesc>(
                "mysql",
                Sink::has_mysql,
                Sink::get_mysql,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RedisDesc>(
                "redis",
                Sink::has_redis,
                Sink::get_redis,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Sink>(
                "Sink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Sink {
        static instance: ::protobuf::rt::LazyV2<Sink> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Sink::new)
    }
}

impl ::protobuf::Clear for Sink {
    fn clear(&mut self) {
        self.desc = ::std::option::Option::None;
        self.desc = ::std::option::Option::None;
        self.desc = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Sink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sink {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConstOp {
    // message fields
    pub value: ::std::vec::Vec<u8>,
    pub operator_id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConstOp {
    fn default() -> &'a ConstOp {
        <ConstOp as ::protobuf::Message>::default_instance()
    }
}

impl ConstOp {
    pub fn new() -> ConstOp {
        ::std::default::Default::default()
    }

    // bytes value = 1;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // uint32 operator_id = 2;


    pub fn get_operator_id(&self) -> u32 {
        self.operator_id
    }
    pub fn clear_operator_id(&mut self) {
        self.operator_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_operator_id(&mut self, v: u32) {
        self.operator_id = v;
    }
}

impl ::protobuf::Message for ConstOp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.operator_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.value);
        }
        if self.operator_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.operator_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_bytes(1, &self.value)?;
        }
        if self.operator_id != 0 {
            os.write_uint32(2, self.operator_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConstOp {
        ConstOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &ConstOp| { &m.value },
                |m: &mut ConstOp| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "operator_id",
                |m: &ConstOp| { &m.operator_id },
                |m: &mut ConstOp| { &mut m.operator_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConstOp>(
                "ConstOp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConstOp {
        static instance: ::protobuf::rt::LazyV2<ConstOp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConstOp::new)
    }
}

impl ::protobuf::Clear for ConstOp {
    fn clear(&mut self) {
        self.value.clear();
        self.operator_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConstOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConstOp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Source {
    // message oneof groups
    pub desc: ::std::option::Option<Source_oneof_desc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Source {
    fn default() -> &'a Source {
        <Source as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Source_oneof_desc {
    kafka(KafkaDesc),
}

impl Source {
    pub fn new() -> Source {
        ::std::default::Default::default()
    }

    // .common.KafkaDesc kafka = 3;


    pub fn get_kafka(&self) -> &KafkaDesc {
        match self.desc {
            ::std::option::Option::Some(Source_oneof_desc::kafka(ref v)) => v,
            _ => <KafkaDesc as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_kafka(&mut self) {
        self.desc = ::std::option::Option::None;
    }

    pub fn has_kafka(&self) -> bool {
        match self.desc {
            ::std::option::Option::Some(Source_oneof_desc::kafka(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_kafka(&mut self, v: KafkaDesc) {
        self.desc = ::std::option::Option::Some(Source_oneof_desc::kafka(v))
    }

    // Mutable pointer to the field.
    pub fn mut_kafka(&mut self) -> &mut KafkaDesc {
        if let ::std::option::Option::Some(Source_oneof_desc::kafka(_)) = self.desc {
        } else {
            self.desc = ::std::option::Option::Some(Source_oneof_desc::kafka(KafkaDesc::new()));
        }
        match self.desc {
            ::std::option::Option::Some(Source_oneof_desc::kafka(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_kafka(&mut self) -> KafkaDesc {
        if self.has_kafka() {
            match self.desc.take() {
                ::std::option::Option::Some(Source_oneof_desc::kafka(v)) => v,
                _ => panic!(),
            }
        } else {
            KafkaDesc::new()
        }
    }
}

impl ::protobuf::Message for Source {
    fn is_initialized(&self) -> bool {
        if let Some(Source_oneof_desc::kafka(ref v)) = self.desc {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.desc = ::std::option::Option::Some(Source_oneof_desc::kafka(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.desc {
            match v {
                &Source_oneof_desc::kafka(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.desc {
            match v {
                &Source_oneof_desc::kafka(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Source {
        Source::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, KafkaDesc>(
                "kafka",
                Source::has_kafka,
                Source::get_kafka,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Source>(
                "Source",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Source {
        static instance: ::protobuf::rt::LazyV2<Source> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Source::new)
    }
}

impl ::protobuf::Clear for Source {
    fn clear(&mut self) {
        self.desc = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Source {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Source {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KafkaDesc {
    // message fields
    pub brokers: ::protobuf::RepeatedField<::std::string::String>,
    pub topic: ::std::string::String,
    pub opts: ::protobuf::SingularPtrField<KafkaDesc_KafkaOptions>,
    pub data_type: super::common::DataTypeEnum,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KafkaDesc {
    fn default() -> &'a KafkaDesc {
        <KafkaDesc as ::protobuf::Message>::default_instance()
    }
}

impl KafkaDesc {
    pub fn new() -> KafkaDesc {
        ::std::default::Default::default()
    }

    // repeated string brokers = 1;


    pub fn get_brokers(&self) -> &[::std::string::String] {
        &self.brokers
    }
    pub fn clear_brokers(&mut self) {
        self.brokers.clear();
    }

    // Param is passed by value, moved
    pub fn set_brokers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.brokers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_brokers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.brokers
    }

    // Take field
    pub fn take_brokers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.brokers, ::protobuf::RepeatedField::new())
    }

    // string topic = 2;


    pub fn get_topic(&self) -> &str {
        &self.topic
    }
    pub fn clear_topic(&mut self) {
        self.topic.clear();
    }

    // Param is passed by value, moved
    pub fn set_topic(&mut self, v: ::std::string::String) {
        self.topic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topic(&mut self) -> &mut ::std::string::String {
        &mut self.topic
    }

    // Take field
    pub fn take_topic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.topic, ::std::string::String::new())
    }

    // .common.KafkaDesc.KafkaOptions opts = 3;


    pub fn get_opts(&self) -> &KafkaDesc_KafkaOptions {
        self.opts.as_ref().unwrap_or_else(|| <KafkaDesc_KafkaOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_opts(&mut self) {
        self.opts.clear();
    }

    pub fn has_opts(&self) -> bool {
        self.opts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opts(&mut self, v: KafkaDesc_KafkaOptions) {
        self.opts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_opts(&mut self) -> &mut KafkaDesc_KafkaOptions {
        if self.opts.is_none() {
            self.opts.set_default();
        }
        self.opts.as_mut().unwrap()
    }

    // Take field
    pub fn take_opts(&mut self) -> KafkaDesc_KafkaOptions {
        self.opts.take().unwrap_or_else(|| KafkaDesc_KafkaOptions::new())
    }

    // .common.DataTypeEnum data_type = 4;


    pub fn get_data_type(&self) -> super::common::DataTypeEnum {
        self.data_type
    }
    pub fn clear_data_type(&mut self) {
        self.data_type = super::common::DataTypeEnum::DATA_TYPE_ENUM_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: super::common::DataTypeEnum) {
        self.data_type = v;
    }
}

impl ::protobuf::Message for KafkaDesc {
    fn is_initialized(&self) -> bool {
        for v in &self.opts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.brokers)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.topic)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.opts)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.data_type, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.brokers {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.topic.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.topic);
        }
        if let Some(ref v) = self.opts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.data_type != super::common::DataTypeEnum::DATA_TYPE_ENUM_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.data_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.brokers {
            os.write_string(1, &v)?;
        };
        if !self.topic.is_empty() {
            os.write_string(2, &self.topic)?;
        }
        if let Some(ref v) = self.opts.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.data_type != super::common::DataTypeEnum::DATA_TYPE_ENUM_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.data_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KafkaDesc {
        KafkaDesc::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "brokers",
                |m: &KafkaDesc| { &m.brokers },
                |m: &mut KafkaDesc| { &mut m.brokers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "topic",
                |m: &KafkaDesc| { &m.topic },
                |m: &mut KafkaDesc| { &mut m.topic },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KafkaDesc_KafkaOptions>>(
                "opts",
                |m: &KafkaDesc| { &m.opts },
                |m: &mut KafkaDesc| { &mut m.opts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::common::DataTypeEnum>>(
                "data_type",
                |m: &KafkaDesc| { &m.data_type },
                |m: &mut KafkaDesc| { &mut m.data_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KafkaDesc>(
                "KafkaDesc",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KafkaDesc {
        static instance: ::protobuf::rt::LazyV2<KafkaDesc> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KafkaDesc::new)
    }
}

impl ::protobuf::Clear for KafkaDesc {
    fn clear(&mut self) {
        self.brokers.clear();
        self.topic.clear();
        self.opts.clear();
        self.data_type = super::common::DataTypeEnum::DATA_TYPE_ENUM_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KafkaDesc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KafkaDesc {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KafkaDesc_KafkaOptions {
    // message oneof groups
    pub opt: ::std::option::Option<KafkaDesc_KafkaOptions_oneof_opt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KafkaDesc_KafkaOptions {
    fn default() -> &'a KafkaDesc_KafkaOptions {
        <KafkaDesc_KafkaOptions as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum KafkaDesc_KafkaOptions_oneof_opt {
    group(::std::string::String),
    partition(u32),
}

impl KafkaDesc_KafkaOptions {
    pub fn new() -> KafkaDesc_KafkaOptions {
        ::std::default::Default::default()
    }

    // string group = 1;


    pub fn get_group(&self) -> &str {
        match self.opt {
            ::std::option::Option::Some(KafkaDesc_KafkaOptions_oneof_opt::group(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_group(&mut self) {
        self.opt = ::std::option::Option::None;
    }

    pub fn has_group(&self) -> bool {
        match self.opt {
            ::std::option::Option::Some(KafkaDesc_KafkaOptions_oneof_opt::group(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.opt = ::std::option::Option::Some(KafkaDesc_KafkaOptions_oneof_opt::group(v))
    }

    // Mutable pointer to the field.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(KafkaDesc_KafkaOptions_oneof_opt::group(_)) = self.opt {
        } else {
            self.opt = ::std::option::Option::Some(KafkaDesc_KafkaOptions_oneof_opt::group(::std::string::String::new()));
        }
        match self.opt {
            ::std::option::Option::Some(KafkaDesc_KafkaOptions_oneof_opt::group(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        if self.has_group() {
            match self.opt.take() {
                ::std::option::Option::Some(KafkaDesc_KafkaOptions_oneof_opt::group(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // uint32 partition = 2;


    pub fn get_partition(&self) -> u32 {
        match self.opt {
            ::std::option::Option::Some(KafkaDesc_KafkaOptions_oneof_opt::partition(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_partition(&mut self) {
        self.opt = ::std::option::Option::None;
    }

    pub fn has_partition(&self) -> bool {
        match self.opt {
            ::std::option::Option::Some(KafkaDesc_KafkaOptions_oneof_opt::partition(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_partition(&mut self, v: u32) {
        self.opt = ::std::option::Option::Some(KafkaDesc_KafkaOptions_oneof_opt::partition(v))
    }
}

impl ::protobuf::Message for KafkaDesc_KafkaOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.opt = ::std::option::Option::Some(KafkaDesc_KafkaOptions_oneof_opt::group(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.opt = ::std::option::Option::Some(KafkaDesc_KafkaOptions_oneof_opt::partition(is.read_uint32()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.opt {
            match v {
                &KafkaDesc_KafkaOptions_oneof_opt::group(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &KafkaDesc_KafkaOptions_oneof_opt::partition(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.opt {
            match v {
                &KafkaDesc_KafkaOptions_oneof_opt::group(ref v) => {
                    os.write_string(1, v)?;
                },
                &KafkaDesc_KafkaOptions_oneof_opt::partition(v) => {
                    os.write_uint32(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KafkaDesc_KafkaOptions {
        KafkaDesc_KafkaOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "group",
                KafkaDesc_KafkaOptions::has_group,
                KafkaDesc_KafkaOptions::get_group,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "partition",
                KafkaDesc_KafkaOptions::has_partition,
                KafkaDesc_KafkaOptions::get_partition,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KafkaDesc_KafkaOptions>(
                "KafkaDesc.KafkaOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KafkaDesc_KafkaOptions {
        static instance: ::protobuf::rt::LazyV2<KafkaDesc_KafkaOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KafkaDesc_KafkaOptions::new)
    }
}

impl ::protobuf::Clear for KafkaDesc_KafkaOptions {
    fn clear(&mut self) {
        self.opt = ::std::option::Option::None;
        self.opt = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KafkaDesc_KafkaOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KafkaDesc_KafkaOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MysqlDesc {
    // message fields
    pub connection_opts: ::protobuf::SingularPtrField<MysqlDesc_ConnectionOpts>,
    pub statement: ::protobuf::SingularPtrField<MysqlDesc_Statement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MysqlDesc {
    fn default() -> &'a MysqlDesc {
        <MysqlDesc as ::protobuf::Message>::default_instance()
    }
}

impl MysqlDesc {
    pub fn new() -> MysqlDesc {
        ::std::default::Default::default()
    }

    // .common.MysqlDesc.ConnectionOpts connection_opts = 1;


    pub fn get_connection_opts(&self) -> &MysqlDesc_ConnectionOpts {
        self.connection_opts.as_ref().unwrap_or_else(|| <MysqlDesc_ConnectionOpts as ::protobuf::Message>::default_instance())
    }
    pub fn clear_connection_opts(&mut self) {
        self.connection_opts.clear();
    }

    pub fn has_connection_opts(&self) -> bool {
        self.connection_opts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_opts(&mut self, v: MysqlDesc_ConnectionOpts) {
        self.connection_opts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_opts(&mut self) -> &mut MysqlDesc_ConnectionOpts {
        if self.connection_opts.is_none() {
            self.connection_opts.set_default();
        }
        self.connection_opts.as_mut().unwrap()
    }

    // Take field
    pub fn take_connection_opts(&mut self) -> MysqlDesc_ConnectionOpts {
        self.connection_opts.take().unwrap_or_else(|| MysqlDesc_ConnectionOpts::new())
    }

    // .common.MysqlDesc.Statement statement = 2;


    pub fn get_statement(&self) -> &MysqlDesc_Statement {
        self.statement.as_ref().unwrap_or_else(|| <MysqlDesc_Statement as ::protobuf::Message>::default_instance())
    }
    pub fn clear_statement(&mut self) {
        self.statement.clear();
    }

    pub fn has_statement(&self) -> bool {
        self.statement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statement(&mut self, v: MysqlDesc_Statement) {
        self.statement = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statement(&mut self) -> &mut MysqlDesc_Statement {
        if self.statement.is_none() {
            self.statement.set_default();
        }
        self.statement.as_mut().unwrap()
    }

    // Take field
    pub fn take_statement(&mut self) -> MysqlDesc_Statement {
        self.statement.take().unwrap_or_else(|| MysqlDesc_Statement::new())
    }
}

impl ::protobuf::Message for MysqlDesc {
    fn is_initialized(&self) -> bool {
        for v in &self.connection_opts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statement {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connection_opts)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statement)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.connection_opts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.statement.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.connection_opts.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.statement.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MysqlDesc {
        MysqlDesc::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MysqlDesc_ConnectionOpts>>(
                "connection_opts",
                |m: &MysqlDesc| { &m.connection_opts },
                |m: &mut MysqlDesc| { &mut m.connection_opts },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MysqlDesc_Statement>>(
                "statement",
                |m: &MysqlDesc| { &m.statement },
                |m: &mut MysqlDesc| { &mut m.statement },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MysqlDesc>(
                "MysqlDesc",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MysqlDesc {
        static instance: ::protobuf::rt::LazyV2<MysqlDesc> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MysqlDesc::new)
    }
}

impl ::protobuf::Clear for MysqlDesc {
    fn clear(&mut self) {
        self.connection_opts.clear();
        self.statement.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MysqlDesc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MysqlDesc {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MysqlDesc_ConnectionOpts {
    // message fields
    pub host: ::std::string::String,
    pub username: ::std::string::String,
    pub password: ::std::string::String,
    pub database: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MysqlDesc_ConnectionOpts {
    fn default() -> &'a MysqlDesc_ConnectionOpts {
        <MysqlDesc_ConnectionOpts as ::protobuf::Message>::default_instance()
    }
}

impl MysqlDesc_ConnectionOpts {
    pub fn new() -> MysqlDesc_ConnectionOpts {
        ::std::default::Default::default()
    }

    // string host = 1;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }

    // string username = 2;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    // string password = 3;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    // string database = 4;


    pub fn get_database(&self) -> &str {
        &self.database
    }
    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MysqlDesc_ConnectionOpts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.password);
        }
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.database);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if !self.username.is_empty() {
            os.write_string(2, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_string(3, &self.password)?;
        }
        if !self.database.is_empty() {
            os.write_string(4, &self.database)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MysqlDesc_ConnectionOpts {
        MysqlDesc_ConnectionOpts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &MysqlDesc_ConnectionOpts| { &m.host },
                |m: &mut MysqlDesc_ConnectionOpts| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "username",
                |m: &MysqlDesc_ConnectionOpts| { &m.username },
                |m: &mut MysqlDesc_ConnectionOpts| { &mut m.username },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &MysqlDesc_ConnectionOpts| { &m.password },
                |m: &mut MysqlDesc_ConnectionOpts| { &mut m.password },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database",
                |m: &MysqlDesc_ConnectionOpts| { &m.database },
                |m: &mut MysqlDesc_ConnectionOpts| { &mut m.database },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MysqlDesc_ConnectionOpts>(
                "MysqlDesc.ConnectionOpts",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MysqlDesc_ConnectionOpts {
        static instance: ::protobuf::rt::LazyV2<MysqlDesc_ConnectionOpts> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MysqlDesc_ConnectionOpts::new)
    }
}

impl ::protobuf::Clear for MysqlDesc_ConnectionOpts {
    fn clear(&mut self) {
        self.host.clear();
        self.username.clear();
        self.password.clear();
        self.database.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MysqlDesc_ConnectionOpts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MysqlDesc_ConnectionOpts {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MysqlDesc_Statement {
    // message fields
    pub statement: ::std::string::String,
    pub extractors: ::protobuf::RepeatedField<MysqlDesc_Statement_Extractor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MysqlDesc_Statement {
    fn default() -> &'a MysqlDesc_Statement {
        <MysqlDesc_Statement as ::protobuf::Message>::default_instance()
    }
}

impl MysqlDesc_Statement {
    pub fn new() -> MysqlDesc_Statement {
        ::std::default::Default::default()
    }

    // string statement = 1;


    pub fn get_statement(&self) -> &str {
        &self.statement
    }
    pub fn clear_statement(&mut self) {
        self.statement.clear();
    }

    // Param is passed by value, moved
    pub fn set_statement(&mut self, v: ::std::string::String) {
        self.statement = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statement(&mut self) -> &mut ::std::string::String {
        &mut self.statement
    }

    // Take field
    pub fn take_statement(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.statement, ::std::string::String::new())
    }

    // repeated .common.MysqlDesc.Statement.Extractor extractors = 2;


    pub fn get_extractors(&self) -> &[MysqlDesc_Statement_Extractor] {
        &self.extractors
    }
    pub fn clear_extractors(&mut self) {
        self.extractors.clear();
    }

    // Param is passed by value, moved
    pub fn set_extractors(&mut self, v: ::protobuf::RepeatedField<MysqlDesc_Statement_Extractor>) {
        self.extractors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extractors(&mut self) -> &mut ::protobuf::RepeatedField<MysqlDesc_Statement_Extractor> {
        &mut self.extractors
    }

    // Take field
    pub fn take_extractors(&mut self) -> ::protobuf::RepeatedField<MysqlDesc_Statement_Extractor> {
        ::std::mem::replace(&mut self.extractors, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MysqlDesc_Statement {
    fn is_initialized(&self) -> bool {
        for v in &self.extractors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.statement)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extractors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.statement.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.statement);
        }
        for value in &self.extractors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.statement.is_empty() {
            os.write_string(1, &self.statement)?;
        }
        for v in &self.extractors {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MysqlDesc_Statement {
        MysqlDesc_Statement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "statement",
                |m: &MysqlDesc_Statement| { &m.statement },
                |m: &mut MysqlDesc_Statement| { &mut m.statement },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MysqlDesc_Statement_Extractor>>(
                "extractors",
                |m: &MysqlDesc_Statement| { &m.extractors },
                |m: &mut MysqlDesc_Statement| { &mut m.extractors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MysqlDesc_Statement>(
                "MysqlDesc.Statement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MysqlDesc_Statement {
        static instance: ::protobuf::rt::LazyV2<MysqlDesc_Statement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MysqlDesc_Statement::new)
    }
}

impl ::protobuf::Clear for MysqlDesc_Statement {
    fn clear(&mut self) {
        self.statement.clear();
        self.extractors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MysqlDesc_Statement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MysqlDesc_Statement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MysqlDesc_Statement_Extractor {
    // message fields
    pub index: u32,
    pub extractor: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MysqlDesc_Statement_Extractor {
    fn default() -> &'a MysqlDesc_Statement_Extractor {
        <MysqlDesc_Statement_Extractor as ::protobuf::Message>::default_instance()
    }
}

impl MysqlDesc_Statement_Extractor {
    pub fn new() -> MysqlDesc_Statement_Extractor {
        ::std::default::Default::default()
    }

    // uint32 index = 1;


    pub fn get_index(&self) -> u32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = v;
    }

    // string extractor = 2;


    pub fn get_extractor(&self) -> &str {
        &self.extractor
    }
    pub fn clear_extractor(&mut self) {
        self.extractor.clear();
    }

    // Param is passed by value, moved
    pub fn set_extractor(&mut self, v: ::std::string::String) {
        self.extractor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extractor(&mut self) -> &mut ::std::string::String {
        &mut self.extractor
    }

    // Take field
    pub fn take_extractor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.extractor, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MysqlDesc_Statement_Extractor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.index = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.extractor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.extractor.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.extractor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.index != 0 {
            os.write_uint32(1, self.index)?;
        }
        if !self.extractor.is_empty() {
            os.write_string(2, &self.extractor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MysqlDesc_Statement_Extractor {
        MysqlDesc_Statement_Extractor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "index",
                |m: &MysqlDesc_Statement_Extractor| { &m.index },
                |m: &mut MysqlDesc_Statement_Extractor| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "extractor",
                |m: &MysqlDesc_Statement_Extractor| { &m.extractor },
                |m: &mut MysqlDesc_Statement_Extractor| { &mut m.extractor },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MysqlDesc_Statement_Extractor>(
                "MysqlDesc.Statement.Extractor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MysqlDesc_Statement_Extractor {
        static instance: ::protobuf::rt::LazyV2<MysqlDesc_Statement_Extractor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MysqlDesc_Statement_Extractor::new)
    }
}

impl ::protobuf::Clear for MysqlDesc_Statement_Extractor {
    fn clear(&mut self) {
        self.index = 0;
        self.extractor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MysqlDesc_Statement_Extractor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MysqlDesc_Statement_Extractor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RedisDesc {
    // message fields
    pub connection_opts: ::protobuf::SingularPtrField<RedisDesc_ConnectionOpts>,
    pub key_extractor: ::protobuf::SingularPtrField<Func>,
    pub value_extractor: ::protobuf::SingularPtrField<Func>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedisDesc {
    fn default() -> &'a RedisDesc {
        <RedisDesc as ::protobuf::Message>::default_instance()
    }
}

impl RedisDesc {
    pub fn new() -> RedisDesc {
        ::std::default::Default::default()
    }

    // .common.RedisDesc.ConnectionOpts connection_opts = 1;


    pub fn get_connection_opts(&self) -> &RedisDesc_ConnectionOpts {
        self.connection_opts.as_ref().unwrap_or_else(|| <RedisDesc_ConnectionOpts as ::protobuf::Message>::default_instance())
    }
    pub fn clear_connection_opts(&mut self) {
        self.connection_opts.clear();
    }

    pub fn has_connection_opts(&self) -> bool {
        self.connection_opts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_opts(&mut self, v: RedisDesc_ConnectionOpts) {
        self.connection_opts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_opts(&mut self) -> &mut RedisDesc_ConnectionOpts {
        if self.connection_opts.is_none() {
            self.connection_opts.set_default();
        }
        self.connection_opts.as_mut().unwrap()
    }

    // Take field
    pub fn take_connection_opts(&mut self) -> RedisDesc_ConnectionOpts {
        self.connection_opts.take().unwrap_or_else(|| RedisDesc_ConnectionOpts::new())
    }

    // .common.Func key_extractor = 2;


    pub fn get_key_extractor(&self) -> &Func {
        self.key_extractor.as_ref().unwrap_or_else(|| <Func as ::protobuf::Message>::default_instance())
    }
    pub fn clear_key_extractor(&mut self) {
        self.key_extractor.clear();
    }

    pub fn has_key_extractor(&self) -> bool {
        self.key_extractor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_extractor(&mut self, v: Func) {
        self.key_extractor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_extractor(&mut self) -> &mut Func {
        if self.key_extractor.is_none() {
            self.key_extractor.set_default();
        }
        self.key_extractor.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_extractor(&mut self) -> Func {
        self.key_extractor.take().unwrap_or_else(|| Func::new())
    }

    // .common.Func value_extractor = 3;


    pub fn get_value_extractor(&self) -> &Func {
        self.value_extractor.as_ref().unwrap_or_else(|| <Func as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value_extractor(&mut self) {
        self.value_extractor.clear();
    }

    pub fn has_value_extractor(&self) -> bool {
        self.value_extractor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_extractor(&mut self, v: Func) {
        self.value_extractor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_extractor(&mut self) -> &mut Func {
        if self.value_extractor.is_none() {
            self.value_extractor.set_default();
        }
        self.value_extractor.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_extractor(&mut self) -> Func {
        self.value_extractor.take().unwrap_or_else(|| Func::new())
    }
}

impl ::protobuf::Message for RedisDesc {
    fn is_initialized(&self) -> bool {
        for v in &self.connection_opts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.key_extractor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value_extractor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connection_opts)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key_extractor)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value_extractor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.connection_opts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.key_extractor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value_extractor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.connection_opts.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.key_extractor.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value_extractor.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedisDesc {
        RedisDesc::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RedisDesc_ConnectionOpts>>(
                "connection_opts",
                |m: &RedisDesc| { &m.connection_opts },
                |m: &mut RedisDesc| { &mut m.connection_opts },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Func>>(
                "key_extractor",
                |m: &RedisDesc| { &m.key_extractor },
                |m: &mut RedisDesc| { &mut m.key_extractor },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Func>>(
                "value_extractor",
                |m: &RedisDesc| { &m.value_extractor },
                |m: &mut RedisDesc| { &mut m.value_extractor },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RedisDesc>(
                "RedisDesc",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedisDesc {
        static instance: ::protobuf::rt::LazyV2<RedisDesc> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RedisDesc::new)
    }
}

impl ::protobuf::Clear for RedisDesc {
    fn clear(&mut self) {
        self.connection_opts.clear();
        self.key_extractor.clear();
        self.value_extractor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedisDesc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedisDesc {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RedisDesc_ConnectionOpts {
    // message fields
    pub host: ::std::string::String,
    pub password: ::std::string::String,
    pub database: ::std::string::String,
    pub tls: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedisDesc_ConnectionOpts {
    fn default() -> &'a RedisDesc_ConnectionOpts {
        <RedisDesc_ConnectionOpts as ::protobuf::Message>::default_instance()
    }
}

impl RedisDesc_ConnectionOpts {
    pub fn new() -> RedisDesc_ConnectionOpts {
        ::std::default::Default::default()
    }

    // string host = 1;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    // string database = 3;


    pub fn get_database(&self) -> &str {
        &self.database
    }
    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }

    // bool tls = 4;


    pub fn get_tls(&self) -> bool {
        self.tls
    }
    pub fn clear_tls(&mut self) {
        self.tls = false;
    }

    // Param is passed by value, moved
    pub fn set_tls(&mut self, v: bool) {
        self.tls = v;
    }
}

impl ::protobuf::Message for RedisDesc_ConnectionOpts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tls = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.database);
        }
        if self.tls != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        if !self.database.is_empty() {
            os.write_string(3, &self.database)?;
        }
        if self.tls != false {
            os.write_bool(4, self.tls)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedisDesc_ConnectionOpts {
        RedisDesc_ConnectionOpts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &RedisDesc_ConnectionOpts| { &m.host },
                |m: &mut RedisDesc_ConnectionOpts| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &RedisDesc_ConnectionOpts| { &m.password },
                |m: &mut RedisDesc_ConnectionOpts| { &mut m.password },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "database",
                |m: &RedisDesc_ConnectionOpts| { &m.database },
                |m: &mut RedisDesc_ConnectionOpts| { &mut m.database },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tls",
                |m: &RedisDesc_ConnectionOpts| { &m.tls },
                |m: &mut RedisDesc_ConnectionOpts| { &mut m.tls },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RedisDesc_ConnectionOpts>(
                "RedisDesc.ConnectionOpts",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedisDesc_ConnectionOpts {
        static instance: ::protobuf::rt::LazyV2<RedisDesc_ConnectionOpts> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RedisDesc_ConnectionOpts::new)
    }
}

impl ::protobuf::Clear for RedisDesc_ConnectionOpts {
    fn clear(&mut self) {
        self.host.clear();
        self.password.clear();
        self.database.clear();
        self.tls = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedisDesc_ConnectionOpts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedisDesc_ConnectionOpts {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Dataflow {
    // message fields
    pub job_id: ::protobuf::SingularPtrField<super::common::ResourceId>,
    pub meta: ::protobuf::RepeatedField<DataflowMeta>,
    pub nodes: ::std::collections::HashMap<u32, OperatorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Dataflow {
    fn default() -> &'a Dataflow {
        <Dataflow as ::protobuf::Message>::default_instance()
    }
}

impl Dataflow {
    pub fn new() -> Dataflow {
        ::std::default::Default::default()
    }

    // .common.ResourceId job_id = 1;


    pub fn get_job_id(&self) -> &super::common::ResourceId {
        self.job_id.as_ref().unwrap_or_else(|| <super::common::ResourceId as ::protobuf::Message>::default_instance())
    }
    pub fn clear_job_id(&mut self) {
        self.job_id.clear();
    }

    pub fn has_job_id(&self) -> bool {
        self.job_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_id(&mut self, v: super::common::ResourceId) {
        self.job_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_job_id(&mut self) -> &mut super::common::ResourceId {
        if self.job_id.is_none() {
            self.job_id.set_default();
        }
        self.job_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_job_id(&mut self) -> super::common::ResourceId {
        self.job_id.take().unwrap_or_else(|| super::common::ResourceId::new())
    }

    // repeated .common.DataflowMeta meta = 2;


    pub fn get_meta(&self) -> &[DataflowMeta] {
        &self.meta
    }
    pub fn clear_meta(&mut self) {
        self.meta.clear();
    }

    // Param is passed by value, moved
    pub fn set_meta(&mut self, v: ::protobuf::RepeatedField<DataflowMeta>) {
        self.meta = v;
    }

    // Mutable pointer to the field.
    pub fn mut_meta(&mut self) -> &mut ::protobuf::RepeatedField<DataflowMeta> {
        &mut self.meta
    }

    // Take field
    pub fn take_meta(&mut self) -> ::protobuf::RepeatedField<DataflowMeta> {
        ::std::mem::replace(&mut self.meta, ::protobuf::RepeatedField::new())
    }

    // repeated .common.Dataflow.NodesEntry nodes = 3;


    pub fn get_nodes(&self) -> &::std::collections::HashMap<u32, OperatorInfo> {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::std::collections::HashMap<u32, OperatorInfo>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::std::collections::HashMap<u32, OperatorInfo> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::std::collections::HashMap<u32, OperatorInfo> {
        ::std::mem::replace(&mut self.nodes, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Dataflow {
    fn is_initialized(&self) -> bool {
        for v in &self.job_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.meta {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.job_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.meta)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<OperatorInfo>>(wire_type, is, &mut self.nodes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.job_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.meta {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<OperatorInfo>>(3, &self.nodes);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.job_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.meta {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<OperatorInfo>>(3, &self.nodes, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Dataflow {
        Dataflow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::ResourceId>>(
                "job_id",
                |m: &Dataflow| { &m.job_id },
                |m: &mut Dataflow| { &mut m.job_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataflowMeta>>(
                "meta",
                |m: &Dataflow| { &m.meta },
                |m: &mut Dataflow| { &mut m.meta },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<OperatorInfo>>(
                "nodes",
                |m: &Dataflow| { &m.nodes },
                |m: &mut Dataflow| { &mut m.nodes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Dataflow>(
                "Dataflow",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Dataflow {
        static instance: ::protobuf::rt::LazyV2<Dataflow> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Dataflow::new)
    }
}

impl ::protobuf::Clear for Dataflow {
    fn clear(&mut self) {
        self.job_id.clear();
        self.meta.clear();
        self.nodes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Dataflow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dataflow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamConfig {
    // message fields
    pub window: ::protobuf::SingularPtrField<Window>,
    pub trigger: ::protobuf::SingularPtrField<Trigger>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamConfig {
    fn default() -> &'a StreamConfig {
        <StreamConfig as ::protobuf::Message>::default_instance()
    }
}

impl StreamConfig {
    pub fn new() -> StreamConfig {
        ::std::default::Default::default()
    }

    // .common.Window window = 1;


    pub fn get_window(&self) -> &Window {
        self.window.as_ref().unwrap_or_else(|| <Window as ::protobuf::Message>::default_instance())
    }
    pub fn clear_window(&mut self) {
        self.window.clear();
    }

    pub fn has_window(&self) -> bool {
        self.window.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window(&mut self, v: Window) {
        self.window = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_window(&mut self) -> &mut Window {
        if self.window.is_none() {
            self.window.set_default();
        }
        self.window.as_mut().unwrap()
    }

    // Take field
    pub fn take_window(&mut self) -> Window {
        self.window.take().unwrap_or_else(|| Window::new())
    }

    // .common.Trigger trigger = 2;


    pub fn get_trigger(&self) -> &Trigger {
        self.trigger.as_ref().unwrap_or_else(|| <Trigger as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trigger(&mut self) {
        self.trigger.clear();
    }

    pub fn has_trigger(&self) -> bool {
        self.trigger.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trigger(&mut self, v: Trigger) {
        self.trigger = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trigger(&mut self) -> &mut Trigger {
        if self.trigger.is_none() {
            self.trigger.set_default();
        }
        self.trigger.as_mut().unwrap()
    }

    // Take field
    pub fn take_trigger(&mut self) -> Trigger {
        self.trigger.take().unwrap_or_else(|| Trigger::new())
    }
}

impl ::protobuf::Message for StreamConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.window {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trigger {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.window)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trigger)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.window.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.trigger.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.window.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.trigger.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamConfig {
        StreamConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Window>>(
                "window",
                |m: &StreamConfig| { &m.window },
                |m: &mut StreamConfig| { &mut m.window },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Trigger>>(
                "trigger",
                |m: &StreamConfig| { &m.trigger },
                |m: &mut StreamConfig| { &mut m.trigger },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamConfig>(
                "StreamConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamConfig {
        static instance: ::protobuf::rt::LazyV2<StreamConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamConfig::new)
    }
}

impl ::protobuf::Clear for StreamConfig {
    fn clear(&mut self) {
        self.window.clear();
        self.trigger.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Window {
    // message oneof groups
    pub value: ::std::option::Option<Window_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Window {
    fn default() -> &'a Window {
        <Window as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Window_oneof_value {
    fixed(Window_FixedWindow),
    slide(Window_SlidingWindow),
    session(Window_SessionWindow),
}

impl Window {
    pub fn new() -> Window {
        ::std::default::Default::default()
    }

    // .common.Window.FixedWindow fixed = 1;


    pub fn get_fixed(&self) -> &Window_FixedWindow {
        match self.value {
            ::std::option::Option::Some(Window_oneof_value::fixed(ref v)) => v,
            _ => <Window_FixedWindow as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_fixed(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_fixed(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Window_oneof_value::fixed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fixed(&mut self, v: Window_FixedWindow) {
        self.value = ::std::option::Option::Some(Window_oneof_value::fixed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fixed(&mut self) -> &mut Window_FixedWindow {
        if let ::std::option::Option::Some(Window_oneof_value::fixed(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Window_oneof_value::fixed(Window_FixedWindow::new()));
        }
        match self.value {
            ::std::option::Option::Some(Window_oneof_value::fixed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fixed(&mut self) -> Window_FixedWindow {
        if self.has_fixed() {
            match self.value.take() {
                ::std::option::Option::Some(Window_oneof_value::fixed(v)) => v,
                _ => panic!(),
            }
        } else {
            Window_FixedWindow::new()
        }
    }

    // .common.Window.SlidingWindow slide = 2;


    pub fn get_slide(&self) -> &Window_SlidingWindow {
        match self.value {
            ::std::option::Option::Some(Window_oneof_value::slide(ref v)) => v,
            _ => <Window_SlidingWindow as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_slide(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_slide(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Window_oneof_value::slide(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_slide(&mut self, v: Window_SlidingWindow) {
        self.value = ::std::option::Option::Some(Window_oneof_value::slide(v))
    }

    // Mutable pointer to the field.
    pub fn mut_slide(&mut self) -> &mut Window_SlidingWindow {
        if let ::std::option::Option::Some(Window_oneof_value::slide(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Window_oneof_value::slide(Window_SlidingWindow::new()));
        }
        match self.value {
            ::std::option::Option::Some(Window_oneof_value::slide(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_slide(&mut self) -> Window_SlidingWindow {
        if self.has_slide() {
            match self.value.take() {
                ::std::option::Option::Some(Window_oneof_value::slide(v)) => v,
                _ => panic!(),
            }
        } else {
            Window_SlidingWindow::new()
        }
    }

    // .common.Window.SessionWindow session = 3;


    pub fn get_session(&self) -> &Window_SessionWindow {
        match self.value {
            ::std::option::Option::Some(Window_oneof_value::session(ref v)) => v,
            _ => <Window_SessionWindow as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_session(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Window_oneof_value::session(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: Window_SessionWindow) {
        self.value = ::std::option::Option::Some(Window_oneof_value::session(v))
    }

    // Mutable pointer to the field.
    pub fn mut_session(&mut self) -> &mut Window_SessionWindow {
        if let ::std::option::Option::Some(Window_oneof_value::session(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Window_oneof_value::session(Window_SessionWindow::new()));
        }
        match self.value {
            ::std::option::Option::Some(Window_oneof_value::session(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_session(&mut self) -> Window_SessionWindow {
        if self.has_session() {
            match self.value.take() {
                ::std::option::Option::Some(Window_oneof_value::session(v)) => v,
                _ => panic!(),
            }
        } else {
            Window_SessionWindow::new()
        }
    }
}

impl ::protobuf::Message for Window {
    fn is_initialized(&self) -> bool {
        if let Some(Window_oneof_value::fixed(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Window_oneof_value::slide(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Window_oneof_value::session(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Window_oneof_value::fixed(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Window_oneof_value::slide(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Window_oneof_value::session(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Window_oneof_value::fixed(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Window_oneof_value::slide(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Window_oneof_value::session(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Window_oneof_value::fixed(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Window_oneof_value::slide(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Window_oneof_value::session(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Window {
        Window::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Window_FixedWindow>(
                "fixed",
                Window::has_fixed,
                Window::get_fixed,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Window_SlidingWindow>(
                "slide",
                Window::has_slide,
                Window::get_slide,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Window_SessionWindow>(
                "session",
                Window::has_session,
                Window::get_session,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Window>(
                "Window",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Window {
        static instance: ::protobuf::rt::LazyV2<Window> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Window::new)
    }
}

impl ::protobuf::Clear for Window {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Window {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Window {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Window_FixedWindow {
    // message fields
    pub size: ::protobuf::SingularPtrField<super::common::Time>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Window_FixedWindow {
    fn default() -> &'a Window_FixedWindow {
        <Window_FixedWindow as ::protobuf::Message>::default_instance()
    }
}

impl Window_FixedWindow {
    pub fn new() -> Window_FixedWindow {
        ::std::default::Default::default()
    }

    // .common.Time size = 1;


    pub fn get_size(&self) -> &super::common::Time {
        self.size.as_ref().unwrap_or_else(|| <super::common::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_size(&mut self) {
        self.size.clear();
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: super::common::Time) {
        self.size = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_size(&mut self) -> &mut super::common::Time {
        if self.size.is_none() {
            self.size.set_default();
        }
        self.size.as_mut().unwrap()
    }

    // Take field
    pub fn take_size(&mut self) -> super::common::Time {
        self.size.take().unwrap_or_else(|| super::common::Time::new())
    }
}

impl ::protobuf::Message for Window_FixedWindow {
    fn is_initialized(&self) -> bool {
        for v in &self.size {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.size)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.size.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.size.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Window_FixedWindow {
        Window_FixedWindow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Time>>(
                "size",
                |m: &Window_FixedWindow| { &m.size },
                |m: &mut Window_FixedWindow| { &mut m.size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Window_FixedWindow>(
                "Window.FixedWindow",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Window_FixedWindow {
        static instance: ::protobuf::rt::LazyV2<Window_FixedWindow> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Window_FixedWindow::new)
    }
}

impl ::protobuf::Clear for Window_FixedWindow {
    fn clear(&mut self) {
        self.size.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Window_FixedWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Window_FixedWindow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Window_SlidingWindow {
    // message fields
    pub size: ::protobuf::SingularPtrField<super::common::Time>,
    pub period: ::protobuf::SingularPtrField<super::common::Time>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Window_SlidingWindow {
    fn default() -> &'a Window_SlidingWindow {
        <Window_SlidingWindow as ::protobuf::Message>::default_instance()
    }
}

impl Window_SlidingWindow {
    pub fn new() -> Window_SlidingWindow {
        ::std::default::Default::default()
    }

    // .common.Time size = 1;


    pub fn get_size(&self) -> &super::common::Time {
        self.size.as_ref().unwrap_or_else(|| <super::common::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_size(&mut self) {
        self.size.clear();
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: super::common::Time) {
        self.size = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_size(&mut self) -> &mut super::common::Time {
        if self.size.is_none() {
            self.size.set_default();
        }
        self.size.as_mut().unwrap()
    }

    // Take field
    pub fn take_size(&mut self) -> super::common::Time {
        self.size.take().unwrap_or_else(|| super::common::Time::new())
    }

    // .common.Time period = 2;


    pub fn get_period(&self) -> &super::common::Time {
        self.period.as_ref().unwrap_or_else(|| <super::common::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_period(&mut self) {
        self.period.clear();
    }

    pub fn has_period(&self) -> bool {
        self.period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_period(&mut self, v: super::common::Time) {
        self.period = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_period(&mut self) -> &mut super::common::Time {
        if self.period.is_none() {
            self.period.set_default();
        }
        self.period.as_mut().unwrap()
    }

    // Take field
    pub fn take_period(&mut self) -> super::common::Time {
        self.period.take().unwrap_or_else(|| super::common::Time::new())
    }
}

impl ::protobuf::Message for Window_SlidingWindow {
    fn is_initialized(&self) -> bool {
        for v in &self.size {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.period {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.size)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.period)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.size.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.period.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.size.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.period.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Window_SlidingWindow {
        Window_SlidingWindow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Time>>(
                "size",
                |m: &Window_SlidingWindow| { &m.size },
                |m: &mut Window_SlidingWindow| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Time>>(
                "period",
                |m: &Window_SlidingWindow| { &m.period },
                |m: &mut Window_SlidingWindow| { &mut m.period },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Window_SlidingWindow>(
                "Window.SlidingWindow",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Window_SlidingWindow {
        static instance: ::protobuf::rt::LazyV2<Window_SlidingWindow> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Window_SlidingWindow::new)
    }
}

impl ::protobuf::Clear for Window_SlidingWindow {
    fn clear(&mut self) {
        self.size.clear();
        self.period.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Window_SlidingWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Window_SlidingWindow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Window_SessionWindow {
    // message fields
    pub timeout: ::protobuf::SingularPtrField<super::common::Time>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Window_SessionWindow {
    fn default() -> &'a Window_SessionWindow {
        <Window_SessionWindow as ::protobuf::Message>::default_instance()
    }
}

impl Window_SessionWindow {
    pub fn new() -> Window_SessionWindow {
        ::std::default::Default::default()
    }

    // .common.Time timeout = 1;


    pub fn get_timeout(&self) -> &super::common::Time {
        self.timeout.as_ref().unwrap_or_else(|| <super::common::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_timeout(&mut self) {
        self.timeout.clear();
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: super::common::Time) {
        self.timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeout(&mut self) -> &mut super::common::Time {
        if self.timeout.is_none() {
            self.timeout.set_default();
        }
        self.timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_timeout(&mut self) -> super::common::Time {
        self.timeout.take().unwrap_or_else(|| super::common::Time::new())
    }
}

impl ::protobuf::Message for Window_SessionWindow {
    fn is_initialized(&self) -> bool {
        for v in &self.timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timeout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.timeout.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Window_SessionWindow {
        Window_SessionWindow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Time>>(
                "timeout",
                |m: &Window_SessionWindow| { &m.timeout },
                |m: &mut Window_SessionWindow| { &mut m.timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Window_SessionWindow>(
                "Window.SessionWindow",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Window_SessionWindow {
        static instance: ::protobuf::rt::LazyV2<Window_SessionWindow> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Window_SessionWindow::new)
    }
}

impl ::protobuf::Clear for Window_SessionWindow {
    fn clear(&mut self) {
        self.timeout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Window_SessionWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Window_SessionWindow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Trigger {
    // message oneof groups
    pub value: ::std::option::Option<Trigger_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Trigger {
    fn default() -> &'a Trigger {
        <Trigger as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Trigger_oneof_value {
    watermark(Trigger_Watermark),
}

impl Trigger {
    pub fn new() -> Trigger {
        ::std::default::Default::default()
    }

    // .common.Trigger.Watermark watermark = 1;


    pub fn get_watermark(&self) -> &Trigger_Watermark {
        match self.value {
            ::std::option::Option::Some(Trigger_oneof_value::watermark(ref v)) => v,
            _ => <Trigger_Watermark as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_watermark(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_watermark(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Trigger_oneof_value::watermark(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_watermark(&mut self, v: Trigger_Watermark) {
        self.value = ::std::option::Option::Some(Trigger_oneof_value::watermark(v))
    }

    // Mutable pointer to the field.
    pub fn mut_watermark(&mut self) -> &mut Trigger_Watermark {
        if let ::std::option::Option::Some(Trigger_oneof_value::watermark(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Trigger_oneof_value::watermark(Trigger_Watermark::new()));
        }
        match self.value {
            ::std::option::Option::Some(Trigger_oneof_value::watermark(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_watermark(&mut self) -> Trigger_Watermark {
        if self.has_watermark() {
            match self.value.take() {
                ::std::option::Option::Some(Trigger_oneof_value::watermark(v)) => v,
                _ => panic!(),
            }
        } else {
            Trigger_Watermark::new()
        }
    }
}

impl ::protobuf::Message for Trigger {
    fn is_initialized(&self) -> bool {
        if let Some(Trigger_oneof_value::watermark(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Trigger_oneof_value::watermark(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Trigger_oneof_value::watermark(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Trigger_oneof_value::watermark(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Trigger {
        Trigger::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Trigger_Watermark>(
                "watermark",
                Trigger::has_watermark,
                Trigger::get_watermark,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Trigger>(
                "Trigger",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Trigger {
        static instance: ::protobuf::rt::LazyV2<Trigger> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Trigger::new)
    }
}

impl ::protobuf::Clear for Trigger {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Trigger {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Trigger {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Trigger_Watermark {
    // message fields
    pub mark_time: ::protobuf::SingularPtrField<super::common::Time>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Trigger_Watermark {
    fn default() -> &'a Trigger_Watermark {
        <Trigger_Watermark as ::protobuf::Message>::default_instance()
    }
}

impl Trigger_Watermark {
    pub fn new() -> Trigger_Watermark {
        ::std::default::Default::default()
    }

    // .common.Time mark_time = 1;


    pub fn get_mark_time(&self) -> &super::common::Time {
        self.mark_time.as_ref().unwrap_or_else(|| <super::common::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mark_time(&mut self) {
        self.mark_time.clear();
    }

    pub fn has_mark_time(&self) -> bool {
        self.mark_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mark_time(&mut self, v: super::common::Time) {
        self.mark_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mark_time(&mut self) -> &mut super::common::Time {
        if self.mark_time.is_none() {
            self.mark_time.set_default();
        }
        self.mark_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_mark_time(&mut self) -> super::common::Time {
        self.mark_time.take().unwrap_or_else(|| super::common::Time::new())
    }
}

impl ::protobuf::Message for Trigger_Watermark {
    fn is_initialized(&self) -> bool {
        for v in &self.mark_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mark_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mark_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mark_time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Trigger_Watermark {
        Trigger_Watermark::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Time>>(
                "mark_time",
                |m: &Trigger_Watermark| { &m.mark_time },
                |m: &mut Trigger_Watermark| { &mut m.mark_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Trigger_Watermark>(
                "Trigger.Watermark",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Trigger_Watermark {
        static instance: ::protobuf::rt::LazyV2<Trigger_Watermark> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Trigger_Watermark::new)
    }
}

impl ::protobuf::Clear for Trigger_Watermark {
    fn clear(&mut self) {
        self.mark_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Trigger_Watermark {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Trigger_Watermark {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DataflowStatus {
    INITIALIZED = 0,
    RUNNING = 1,
    CLOSING = 2,
    CLOSED = 3,
}

impl ::protobuf::ProtobufEnum for DataflowStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataflowStatus> {
        match value {
            0 => ::std::option::Option::Some(DataflowStatus::INITIALIZED),
            1 => ::std::option::Option::Some(DataflowStatus::RUNNING),
            2 => ::std::option::Option::Some(DataflowStatus::CLOSING),
            3 => ::std::option::Option::Some(DataflowStatus::CLOSED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataflowStatus] = &[
            DataflowStatus::INITIALIZED,
            DataflowStatus::RUNNING,
            DataflowStatus::CLOSING,
            DataflowStatus::CLOSED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataflowStatus>("DataflowStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DataflowStatus {
}

impl ::std::default::Default for DataflowStatus {
    fn default() -> Self {
        DataflowStatus::INITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DataflowStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13common/stream.proto\x12\x06common\x1a\x13common/common.proto\"D\n\
    \x0cDataflowMeta\x12\x16\n\x06center\x18\x01\x20\x01(\rR\x06center\x12\
    \x1c\n\tneighbors\x18\x02\x20\x03(\rR\tneighbors\"\xda\x03\n\x0cOperator\
    Info\x12\x1f\n\x0boperator_id\x18\x01\x20\x01(\rR\noperatorId\x12-\n\tho\
    st_addr\x18\x02\x20\x01(\x0b2\x10.common.HostAddrR\x08hostAddr\x12,\n\
    \x06config\x18\x03\x20\x01(\x0b2\x14.common.StreamConfigR\x06config\x12\
    \x1c\n\tupstreams\x18\x04\x20\x03(\rR\tupstreams\x12(\n\x06source\x18\
    \x05\x20\x01(\x0b2\x0e.common.SourceH\0R\x06source\x12\"\n\x04sink\x18\
    \x06\x20\x01(\x0b2\x0c.common.SinkH\0R\x04sink\x12(\n\x06mapper\x18\x07\
    \x20\x01(\x0b2\x0e.common.MapperH\0R\x06mapper\x12(\n\x06filter\x18\x08\
    \x20\x01(\x0b2\x0e.common.FilterH\0R\x06filter\x12&\n\x06key_by\x18\t\
    \x20\x01(\x0b2\r.common.KeyByH\0R\x05keyBy\x12+\n\x07reducer\x18\n\x20\
    \x01(\x0b2\x0f.common.ReducerH\0R\x07reducer\x12,\n\x08flat_map\x18\x0b\
    \x20\x01(\x0b2\x0f.common.FlatMapH\0R\x07flatMapB\t\n\x07details\"6\n\
    \x07Reducer\x12\"\n\x04func\x18\x01\x20\x01(\x0b2\x0c.common.FuncH\0R\
    \x04funcB\x07\n\x05value\"6\n\x07FlatMap\x12\"\n\x04func\x18\x01\x20\x01\
    (\x0b2\x0c.common.FuncH\0R\x04funcB\x07\n\x05value\"\x9c\x01\n\x04Join\
    \x12:\n\x0bstream_join\x18\x01\x20\x01(\x0b2\x17.common.Join.StreamJoinH\
    \0R\nstreamJoin\x1aO\n\nStreamJoin\x12\x1f\n\x0boperator_id\x18\x01\x20\
    \x01(\rR\noperatorId\x12\x20\n\x04func\x18\x02\x20\x01(\x0b2\x0c.common.\
    FuncR\x04funcB\x07\n\x05value\"5\n\x06Mapper\x12\"\n\x04func\x18\x01\x20\
    \x01(\x0b2\x0c.common.FuncH\0R\x04funcB\x07\n\x05value\"\"\n\x04Func\x12\
    \x1a\n\x08function\x18\x01\x20\x01(\tR\x08function\"5\n\x06Filter\x12\"\
    \n\x04func\x18\x01\x20\x01(\x0b2\x0c.common.FuncH\0R\x04funcB\x07\n\x05v\
    alue\"4\n\x05KeyBy\x12\"\n\x04func\x18\x01\x20\x01(\x0b2\x0c.common.Func\
    H\0R\x04funcB\x07\n\x05value\"\x8f\x01\n\x04Sink\x12)\n\x05kafka\x18\x01\
    \x20\x01(\x0b2\x11.common.KafkaDescH\0R\x05kafka\x12)\n\x05mysql\x18\x02\
    \x20\x01(\x0b2\x11.common.MysqlDescH\0R\x05mysql\x12)\n\x05redis\x18\x03\
    \x20\x01(\x0b2\x11.common.RedisDescH\0R\x05redisB\x06\n\x04desc\"@\n\x07\
    ConstOp\x12\x14\n\x05value\x18\x01\x20\x01(\x0cR\x05value\x12\x1f\n\x0bo\
    perator_id\x18\x02\x20\x01(\rR\noperatorId\";\n\x06Source\x12)\n\x05kafk\
    a\x18\x03\x20\x01(\x0b2\x11.common.KafkaDescH\0R\x05kafkaB\x06\n\x04desc\
    \"\xf1\x01\n\tKafkaDesc\x12\x18\n\x07brokers\x18\x01\x20\x03(\tR\x07brok\
    ers\x12\x14\n\x05topic\x18\x02\x20\x01(\tR\x05topic\x122\n\x04opts\x18\
    \x03\x20\x01(\x0b2\x1e.common.KafkaDesc.KafkaOptionsR\x04opts\x121\n\tda\
    ta_type\x18\x04\x20\x01(\x0e2\x14.common.DataTypeEnumR\x08dataType\x1aM\
    \n\x0cKafkaOptions\x12\x16\n\x05group\x18\x01\x20\x01(\tH\0R\x05group\
    \x12\x1e\n\tpartition\x18\x02\x20\x01(\rH\0R\tpartitionB\x05\n\x03opt\"\
    \xbf\x03\n\tMysqlDesc\x12I\n\x0fconnection_opts\x18\x01\x20\x01(\x0b2\
    \x20.common.MysqlDesc.ConnectionOptsR\x0econnectionOpts\x129\n\tstatemen\
    t\x18\x02\x20\x01(\x0b2\x1b.common.MysqlDesc.StatementR\tstatement\x1ax\
    \n\x0eConnectionOpts\x12\x12\n\x04host\x18\x01\x20\x01(\tR\x04host\x12\
    \x1a\n\x08username\x18\x02\x20\x01(\tR\x08username\x12\x1a\n\x08password\
    \x18\x03\x20\x01(\tR\x08password\x12\x1a\n\x08database\x18\x04\x20\x01(\
    \tR\x08database\x1a\xb1\x01\n\tStatement\x12\x1c\n\tstatement\x18\x01\
    \x20\x01(\tR\tstatement\x12E\n\nextractors\x18\x02\x20\x03(\x0b2%.common\
    .MysqlDesc.Statement.ExtractorR\nextractors\x1a?\n\tExtractor\x12\x14\n\
    \x05index\x18\x01\x20\x01(\rR\x05index\x12\x1c\n\textractor\x18\x02\x20\
    \x01(\tR\textractor\"\xb0\x02\n\tRedisDesc\x12I\n\x0fconnection_opts\x18\
    \x01\x20\x01(\x0b2\x20.common.RedisDesc.ConnectionOptsR\x0econnectionOpt\
    s\x121\n\rkey_extractor\x18\x02\x20\x01(\x0b2\x0c.common.FuncR\x0ckeyExt\
    ractor\x125\n\x0fvalue_extractor\x18\x03\x20\x01(\x0b2\x0c.common.FuncR\
    \x0evalueExtractor\x1an\n\x0eConnectionOpts\x12\x12\n\x04host\x18\x01\
    \x20\x01(\tR\x04host\x12\x1a\n\x08password\x18\x02\x20\x01(\tR\x08passwo\
    rd\x12\x1a\n\x08database\x18\x03\x20\x01(\tR\x08database\x12\x10\n\x03tl\
    s\x18\x04\x20\x01(\x08R\x03tls\"\xe2\x01\n\x08Dataflow\x12)\n\x06job_id\
    \x18\x01\x20\x01(\x0b2\x12.common.ResourceIdR\x05jobId\x12(\n\x04meta\
    \x18\x02\x20\x03(\x0b2\x14.common.DataflowMetaR\x04meta\x121\n\x05nodes\
    \x18\x03\x20\x03(\x0b2\x1b.common.Dataflow.NodesEntryR\x05nodes\x1aN\n\n\
    NodesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\rR\x03key\x12*\n\x05value\
    \x18\x02\x20\x01(\x0b2\x14.common.OperatorInfoR\x05value:\x028\x01\"a\n\
    \x0cStreamConfig\x12&\n\x06window\x18\x01\x20\x01(\x0b2\x0e.common.Windo\
    wR\x06window\x12)\n\x07trigger\x18\x02\x20\x01(\x0b2\x0f.common.TriggerR\
    \x07trigger\"\xf8\x02\n\x06Window\x122\n\x05fixed\x18\x01\x20\x01(\x0b2\
    \x1a.common.Window.FixedWindowH\0R\x05fixed\x124\n\x05slide\x18\x02\x20\
    \x01(\x0b2\x1c.common.Window.SlidingWindowH\0R\x05slide\x128\n\x07sessio\
    n\x18\x03\x20\x01(\x0b2\x1c.common.Window.SessionWindowH\0R\x07session\
    \x1a/\n\x0bFixedWindow\x12\x20\n\x04size\x18\x01\x20\x01(\x0b2\x0c.commo\
    n.TimeR\x04size\x1aW\n\rSlidingWindow\x12\x20\n\x04size\x18\x01\x20\x01(\
    \x0b2\x0c.common.TimeR\x04size\x12$\n\x06period\x18\x02\x20\x01(\x0b2\
    \x0c.common.TimeR\x06period\x1a7\n\rSessionWindow\x12&\n\x07timeout\x18\
    \x01\x20\x01(\x0b2\x0c.common.TimeR\x07timeoutB\x07\n\x05value\"\x85\x01\
    \n\x07Trigger\x129\n\twatermark\x18\x01\x20\x01(\x0b2\x19.common.Trigger\
    .WatermarkH\0R\twatermark\x1a6\n\tWatermark\x12)\n\tmark_time\x18\x01\
    \x20\x01(\x0b2\x0c.common.TimeR\x08markTimeB\x07\n\x05value*G\n\x0eDataf\
    lowStatus\x12\x0f\n\x0bINITIALIZED\x10\0\x12\x0b\n\x07RUNNING\x10\x01\
    \x12\x0b\n\x07CLOSING\x10\x02\x12\n\n\x06CLOSED\x10\x03BD\n#tableflow.al\
    pha.proto.common.streamZ\x1dtableflow/alpha/common/streamJ\x81/\n\x07\
    \x12\x05\0\0\xca\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\
    \x12\x03\x02\0\x0f\n\t\n\x02\x03\0\x12\x03\x03\0\x1d\n\x08\n\x01\x08\x12\
    \x03\x04\04\n\t\n\x02\x08\x0b\x12\x03\x04\04\n\x08\n\x01\x08\x12\x03\x05\
    \0<\n\t\n\x02\x08\x01\x12\x03\x05\0<\n[\n\x02\x04\0\x12\x04\n\0\r\x01\
    \x1aO*\nStreamGraph\x20metadata,\x20it\x20stores\x20the\x20structural\
    \x20information\x20of\x20a\x20stream\x20graph\n\n\n\n\x03\x04\0\x01\x12\
    \x03\n\x08\x14\n\x1d\n\x04\x04\0\x02\0\x12\x03\x0b\x02\x14\"\x10\x20cent\
    er\x20node\x20id\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x0b\x02\x08\n\x0c\
    \n\x05\x04\0\x02\0\x01\x12\x03\x0b\t\x0f\n\x0c\n\x05\x04\0\x02\0\x03\x12\
    \x03\x0b\x12\x13\n!\n\x04\x04\0\x02\x01\x12\x03\x0c\x02\x20\"\x14\x20cen\
    ter's\x20neighbors\n\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x0c\x02\n\n\
    \x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x0c\x0b\x11\n\x0c\n\x05\x04\0\x02\
    \x01\x01\x12\x03\x0c\x12\x1b\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x0c\
    \x1e\x1f\nE\n\x02\x04\x01\x12\x04\x12\0#\x01\x1a9*\nOperatorInfo,\x20sto\
    res\x20detail\x20information\x20of\x20an\x20operator\n\n\n\n\x03\x04\x01\
    \x01\x12\x03\x12\x08\x14\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x13\x02\x19\n\
    \x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x13\x02\x08\n\x0c\n\x05\x04\x01\x02\
    \0\x01\x12\x03\x13\t\x14\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x13\x17\
    \x18\n\x20\n\x04\x04\x01\x02\x01\x12\x03\x14\x02\x20\"\x13\x20host\x20ad\
    dr\x20configs\n\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03\x14\x02\x11\n\
    \x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x14\x12\x1b\n\x0c\n\x05\x04\x01\
    \x02\x01\x03\x12\x03\x14\x1e\x1f\n)\n\x04\x04\x01\x02\x02\x12\x03\x15\
    \x02\x1a\"\x1c\x20stream\x20config\x20for\x20operator\n\n\x0c\n\x05\x04\
    \x01\x02\x02\x06\x12\x03\x15\x02\x0e\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\
    \x03\x15\x0f\x15\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\x15\x18\x19\n$\
    \n\x04\x04\x01\x02\x03\x12\x03\x16\x02\x20\"\x17\x20upstreams\x20operato\
    r_id\n\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03\x16\x02\n\n\x0c\n\x05\x04\
    \x01\x02\x03\x05\x12\x03\x16\x0b\x11\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\
    \x03\x16\x12\x1b\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03\x16\x1e\x1f\n4\
    \n\x04\x04\x01\x08\0\x12\x04\x19\x02\"\x03\x1a&\x20optional\x20for\x20di\
    fferent\x20operator\x20type\n\n\x0c\n\x05\x04\x01\x08\0\x01\x12\x03\x19\
    \x08\x0f\n\x19\n\x04\x04\x01\x02\x04\x12\x03\x1a\x04\x16\"\x0c\x20for\
    \x20source\n\n\x0c\n\x05\x04\x01\x02\x04\x06\x12\x03\x1a\x04\n\n\x0c\n\
    \x05\x04\x01\x02\x04\x01\x12\x03\x1a\x0b\x11\n\x0c\n\x05\x04\x01\x02\x04\
    \x03\x12\x03\x1a\x14\x15\n\x17\n\x04\x04\x01\x02\x05\x12\x03\x1b\x04\x12\
    \"\n\x20for\x20sink\n\n\x0c\n\x05\x04\x01\x02\x05\x06\x12\x03\x1b\x04\
    \x08\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03\x1b\t\r\n\x0c\n\x05\x04\x01\
    \x02\x05\x03\x12\x03\x1b\x10\x11\n\x0b\n\x04\x04\x01\x02\x06\x12\x03\x1c\
    \x04\x16\n\x0c\n\x05\x04\x01\x02\x06\x06\x12\x03\x1c\x04\n\n\x0c\n\x05\
    \x04\x01\x02\x06\x01\x12\x03\x1c\x0b\x11\n\x0c\n\x05\x04\x01\x02\x06\x03\
    \x12\x03\x1c\x14\x15\n\x0b\n\x04\x04\x01\x02\x07\x12\x03\x1d\x04\x16\n\
    \x0c\n\x05\x04\x01\x02\x07\x06\x12\x03\x1d\x04\n\n\x0c\n\x05\x04\x01\x02\
    \x07\x01\x12\x03\x1d\x0b\x11\n\x0c\n\x05\x04\x01\x02\x07\x03\x12\x03\x1d\
    \x14\x15\n\x0b\n\x04\x04\x01\x02\x08\x12\x03\x1e\x04\x15\n\x0c\n\x05\x04\
    \x01\x02\x08\x06\x12\x03\x1e\x04\t\n\x0c\n\x05\x04\x01\x02\x08\x01\x12\
    \x03\x1e\n\x10\n\x0c\n\x05\x04\x01\x02\x08\x03\x12\x03\x1e\x13\x14\n\x0b\
    \n\x04\x04\x01\x02\t\x12\x03\x1f\x04\x19\n\x0c\n\x05\x04\x01\x02\t\x06\
    \x12\x03\x1f\x04\x0b\n\x0c\n\x05\x04\x01\x02\t\x01\x12\x03\x1f\x0c\x13\n\
    \x0c\n\x05\x04\x01\x02\t\x03\x12\x03\x1f\x16\x18\n!\n\x04\x04\x01\x02\n\
    \x12\x03\x20\x04\x1a\"\x14\x20\x20\x20\x20Join\x20join\x20=\x2011;\n\n\
    \x0c\n\x05\x04\x01\x02\n\x06\x12\x03\x20\x04\x0b\n\x0c\n\x05\x04\x01\x02\
    \n\x01\x12\x03\x20\x0c\x14\n\x0c\n\x05\x04\x01\x02\n\x03\x12\x03\x20\x17\
    \x19\n\n\n\x02\x04\x02\x12\x04$\0(\x01\n\n\n\x03\x04\x02\x01\x12\x03$\
    \x08\x0f\n\x0c\n\x04\x04\x02\x08\0\x12\x04%\x02'\x03\n\x0c\n\x05\x04\x02\
    \x08\0\x01\x12\x03%\x08\r\n\x0b\n\x04\x04\x02\x02\0\x12\x03&\x04\x12\n\
    \x0c\n\x05\x04\x02\x02\0\x06\x12\x03&\x04\x08\n\x0c\n\x05\x04\x02\x02\0\
    \x01\x12\x03&\t\r\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03&\x10\x11\n\n\n\
    \x02\x04\x03\x12\x04*\0.\x01\n\n\n\x03\x04\x03\x01\x12\x03*\x08\x0f\n\
    \x0c\n\x04\x04\x03\x08\0\x12\x04+\x02-\x03\n\x0c\n\x05\x04\x03\x08\0\x01\
    \x12\x03+\x08\r\n\x0b\n\x04\x04\x03\x02\0\x12\x03,\x04\x12\n\x0c\n\x05\
    \x04\x03\x02\0\x06\x12\x03,\x04\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\
    \x03,\t\r\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03,\x10\x11\n\n\n\x02\x04\
    \x04\x12\x040\09\x01\n\n\n\x03\x04\x04\x01\x12\x030\x08\x0c\n\x0c\n\x04\
    \x04\x04\x08\0\x12\x041\x023\x03\n\x0c\n\x05\x04\x04\x08\0\x01\x12\x031\
    \x08\r\n\x0b\n\x04\x04\x04\x02\0\x12\x032\x04\x1f\n\x0c\n\x05\x04\x04\
    \x02\0\x06\x12\x032\x04\x0e\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x032\x0f\
    \x1a\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x032\x1d\x1e\n\x0c\n\x04\x04\x04\
    \x03\0\x12\x045\x028\x03\n\x0c\n\x05\x04\x04\x03\0\x01\x12\x035\n\x14\n\
    \r\n\x06\x04\x04\x03\0\x02\0\x12\x036\x04\x1b\n\x0e\n\x07\x04\x04\x03\0\
    \x02\0\x05\x12\x036\x04\n\n\x0e\n\x07\x04\x04\x03\0\x02\0\x01\x12\x036\
    \x0b\x16\n\x0e\n\x07\x04\x04\x03\0\x02\0\x03\x12\x036\x19\x1a\n\r\n\x06\
    \x04\x04\x03\0\x02\x01\x12\x037\x04\x12\n\x0e\n\x07\x04\x04\x03\0\x02\
    \x01\x06\x12\x037\x04\x08\n\x0e\n\x07\x04\x04\x03\0\x02\x01\x01\x12\x037\
    \t\r\n\x0e\n\x07\x04\x04\x03\0\x02\x01\x03\x12\x037\x10\x11\n\n\n\x02\
    \x04\x05\x12\x04;\0?\x01\n\n\n\x03\x04\x05\x01\x12\x03;\x08\x0e\n\x0c\n\
    \x04\x04\x05\x08\0\x12\x04<\x02>\x03\n\x0c\n\x05\x04\x05\x08\0\x01\x12\
    \x03<\x08\r\n\x0b\n\x04\x04\x05\x02\0\x12\x03=\x04\x12\n\x0c\n\x05\x04\
    \x05\x02\0\x06\x12\x03=\x04\x08\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03=\t\
    \r\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03=\x10\x11\n\n\n\x02\x04\x06\x12\
    \x04A\0C\x01\n\n\n\x03\x04\x06\x01\x12\x03A\x08\x0c\n\x0b\n\x04\x04\x06\
    \x02\0\x12\x03B\x02\x16\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03B\x02\x08\n\
    \x0c\n\x05\x04\x06\x02\0\x01\x12\x03B\t\x11\n\x0c\n\x05\x04\x06\x02\0\
    \x03\x12\x03B\x14\x15\n\n\n\x02\x04\x07\x12\x04E\0I\x01\n\n\n\x03\x04\
    \x07\x01\x12\x03E\x08\x0e\n\x0c\n\x04\x04\x07\x08\0\x12\x04F\x02H\x03\n\
    \x0c\n\x05\x04\x07\x08\0\x01\x12\x03F\x08\r\n\x0b\n\x04\x04\x07\x02\0\
    \x12\x03G\x04\x12\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03G\x04\x08\n\x0c\n\
    \x05\x04\x07\x02\0\x01\x12\x03G\t\r\n\x0c\n\x05\x04\x07\x02\0\x03\x12\
    \x03G\x10\x11\n\n\n\x02\x04\x08\x12\x04K\0O\x01\n\n\n\x03\x04\x08\x01\
    \x12\x03K\x08\r\n\x0c\n\x04\x04\x08\x08\0\x12\x04L\x02N\x03\n\x0c\n\x05\
    \x04\x08\x08\0\x01\x12\x03L\x08\r\n\x0b\n\x04\x04\x08\x02\0\x12\x03M\x04\
    \x12\n\x0c\n\x05\x04\x08\x02\0\x06\x12\x03M\x04\x08\n\x0c\n\x05\x04\x08\
    \x02\0\x01\x12\x03M\t\r\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03M\x10\x11\n\
    \n\n\x02\x04\t\x12\x04Q\0W\x01\n\n\n\x03\x04\t\x01\x12\x03Q\x08\x0c\n\
    \x0c\n\x04\x04\t\x08\0\x12\x04R\x02V\x03\n\x0c\n\x05\x04\t\x08\0\x01\x12\
    \x03R\x08\x0c\n\x0b\n\x04\x04\t\x02\0\x12\x03S\x04\x18\n\x0c\n\x05\x04\t\
    \x02\0\x06\x12\x03S\x04\r\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03S\x0e\x13\n\
    \x0c\n\x05\x04\t\x02\0\x03\x12\x03S\x16\x17\n\x0b\n\x04\x04\t\x02\x01\
    \x12\x03T\x04\x18\n\x0c\n\x05\x04\t\x02\x01\x06\x12\x03T\x04\r\n\x0c\n\
    \x05\x04\t\x02\x01\x01\x12\x03T\x0e\x13\n\x0c\n\x05\x04\t\x02\x01\x03\
    \x12\x03T\x16\x17\n\x0b\n\x04\x04\t\x02\x02\x12\x03U\x04\x18\n\x0c\n\x05\
    \x04\t\x02\x02\x06\x12\x03U\x04\r\n\x0c\n\x05\x04\t\x02\x02\x01\x12\x03U\
    \x0e\x13\n\x0c\n\x05\x04\t\x02\x02\x03\x12\x03U\x16\x17\n\x20\n\x02\x04\
    \n\x12\x04\\\0_\x01\x1a\x14*\nConstant\x20operator\n\n\n\n\x03\x04\n\x01\
    \x12\x03\\\x08\x0f\nE\n\x04\x04\n\x02\0\x12\x03]\x02\x12\"8\x20value\x20\
    of\x20constant,\x20format:\x20[<flag\x20byte>,\x20<data\x20bytes>]\n\n\
    \x0c\n\x05\x04\n\x02\0\x05\x12\x03]\x02\x07\n\x0c\n\x05\x04\n\x02\0\x01\
    \x12\x03]\x08\r\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03]\x10\x11\n\x1a\n\x04\
    \x04\n\x02\x01\x12\x03^\x02\x19\"\r\x20operator\x20id\n\n\x0c\n\x05\x04\
    \n\x02\x01\x05\x12\x03^\x02\x08\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03^\t\
    \x14\n\x0c\n\x05\x04\n\x02\x01\x03\x12\x03^\x17\x18\n\n\n\x02\x04\x0b\
    \x12\x04a\0e\x01\n\n\n\x03\x04\x0b\x01\x12\x03a\x08\x0e\n\x0c\n\x04\x04\
    \x0b\x08\0\x12\x04b\x02d\x03\n\x0c\n\x05\x04\x0b\x08\0\x01\x12\x03b\x08\
    \x0c\n\x0b\n\x04\x04\x0b\x02\0\x12\x03c\x04\x18\n\x0c\n\x05\x04\x0b\x02\
    \0\x06\x12\x03c\x04\r\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03c\x0e\x13\n\
    \x0c\n\x05\x04\x0b\x02\0\x03\x12\x03c\x16\x17\n\n\n\x02\x04\x0c\x12\x04g\
    \0s\x01\n\n\n\x03\x04\x0c\x01\x12\x03g\x08\x11\n\x0b\n\x04\x04\x0c\x02\0\
    \x12\x03h\x02\x1e\n\x0c\n\x05\x04\x0c\x02\0\x04\x12\x03h\x02\n\n\x0c\n\
    \x05\x04\x0c\x02\0\x05\x12\x03h\x0b\x11\n\x0c\n\x05\x04\x0c\x02\0\x01\
    \x12\x03h\x12\x19\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\x03h\x1c\x1d\n\x0b\n\
    \x04\x04\x0c\x02\x01\x12\x03i\x02\x13\n\x0c\n\x05\x04\x0c\x02\x01\x05\
    \x12\x03i\x02\x08\n\x0c\n\x05\x04\x0c\x02\x01\x01\x12\x03i\t\x0e\n\x0c\n\
    \x05\x04\x0c\x02\x01\x03\x12\x03i\x11\x12\n\x0b\n\x04\x04\x0c\x02\x02\
    \x12\x03j\x02\x18\n\x0c\n\x05\x04\x0c\x02\x02\x06\x12\x03j\x02\x0e\n\x0c\
    \n\x05\x04\x0c\x02\x02\x01\x12\x03j\x0f\x13\n\x0c\n\x05\x04\x0c\x02\x02\
    \x03\x12\x03j\x16\x17\n\x0b\n\x04\x04\x0c\x02\x03\x12\x03k\x02\x1d\n\x0c\
    \n\x05\x04\x0c\x02\x03\x06\x12\x03k\x02\x0e\n\x0c\n\x05\x04\x0c\x02\x03\
    \x01\x12\x03k\x0f\x18\n\x0c\n\x05\x04\x0c\x02\x03\x03\x12\x03k\x1b\x1c\n\
    \x0c\n\x04\x04\x0c\x03\0\x12\x04m\x02r\x03\n\x0c\n\x05\x04\x0c\x03\0\x01\
    \x12\x03m\n\x16\n\x0e\n\x06\x04\x0c\x03\0\x08\0\x12\x04n\x04q\x05\n\x0e\
    \n\x07\x04\x0c\x03\0\x08\0\x01\x12\x03n\n\r\n\r\n\x06\x04\x0c\x03\0\x02\
    \0\x12\x03o\x06\x17\n\x0e\n\x07\x04\x0c\x03\0\x02\0\x05\x12\x03o\x06\x0c\
    \n\x0e\n\x07\x04\x0c\x03\0\x02\0\x01\x12\x03o\r\x12\n\x0e\n\x07\x04\x0c\
    \x03\0\x02\0\x03\x12\x03o\x15\x16\n\r\n\x06\x04\x0c\x03\0\x02\x01\x12\
    \x03p\x06\x1b\n\x0e\n\x07\x04\x0c\x03\0\x02\x01\x05\x12\x03p\x06\x0c\n\
    \x0e\n\x07\x04\x0c\x03\0\x02\x01\x01\x12\x03p\r\x16\n\x0e\n\x07\x04\x0c\
    \x03\0\x02\x01\x03\x12\x03p\x19\x1a\n\x0b\n\x02\x04\r\x12\x05u\0\x89\x01\
    \x01\n\n\n\x03\x04\r\x01\x12\x03u\x08\x11\n\x0c\n\x04\x04\r\x03\0\x12\
    \x04v\x02{\x03\n\x0c\n\x05\x04\r\x03\0\x01\x12\x03v\n\x18\n\r\n\x06\x04\
    \r\x03\0\x02\0\x12\x03w\x04\x14\n\x0e\n\x07\x04\r\x03\0\x02\0\x05\x12\
    \x03w\x04\n\n\x0e\n\x07\x04\r\x03\0\x02\0\x01\x12\x03w\x0b\x0f\n\x0e\n\
    \x07\x04\r\x03\0\x02\0\x03\x12\x03w\x12\x13\n\r\n\x06\x04\r\x03\0\x02\
    \x01\x12\x03x\x04\x18\n\x0e\n\x07\x04\r\x03\0\x02\x01\x05\x12\x03x\x04\n\
    \n\x0e\n\x07\x04\r\x03\0\x02\x01\x01\x12\x03x\x0b\x13\n\x0e\n\x07\x04\r\
    \x03\0\x02\x01\x03\x12\x03x\x16\x17\n\r\n\x06\x04\r\x03\0\x02\x02\x12\
    \x03y\x04\x18\n\x0e\n\x07\x04\r\x03\0\x02\x02\x05\x12\x03y\x04\n\n\x0e\n\
    \x07\x04\r\x03\0\x02\x02\x01\x12\x03y\x0b\x13\n\x0e\n\x07\x04\r\x03\0\
    \x02\x02\x03\x12\x03y\x16\x17\n\r\n\x06\x04\r\x03\0\x02\x03\x12\x03z\x04\
    \x18\n\x0e\n\x07\x04\r\x03\0\x02\x03\x05\x12\x03z\x04\n\n\x0e\n\x07\x04\
    \r\x03\0\x02\x03\x01\x12\x03z\x0b\x13\n\x0e\n\x07\x04\r\x03\0\x02\x03\
    \x03\x12\x03z\x16\x17\n\r\n\x04\x04\r\x03\x01\x12\x05}\x02\x85\x01\x03\n\
    \x0c\n\x05\x04\r\x03\x01\x01\x12\x03}\n\x13\n\r\n\x06\x04\r\x03\x01\x02\
    \0\x12\x03~\x04\x19\n\x0e\n\x07\x04\r\x03\x01\x02\0\x05\x12\x03~\x04\n\n\
    \x0e\n\x07\x04\r\x03\x01\x02\0\x01\x12\x03~\x0b\x14\n\x0e\n\x07\x04\r\
    \x03\x01\x02\0\x03\x12\x03~\x17\x18\n\r\n\x06\x04\r\x03\x01\x02\x01\x12\
    \x03\x7f\x04&\n\x0e\n\x07\x04\r\x03\x01\x02\x01\x04\x12\x03\x7f\x04\x0c\
    \n\x0e\n\x07\x04\r\x03\x01\x02\x01\x06\x12\x03\x7f\r\x16\n\x0e\n\x07\x04\
    \r\x03\x01\x02\x01\x01\x12\x03\x7f\x17!\n\x0e\n\x07\x04\r\x03\x01\x02\
    \x01\x03\x12\x03\x7f$%\n\x10\n\x06\x04\r\x03\x01\x03\0\x12\x06\x81\x01\
    \x04\x84\x01\x05\n\x0f\n\x07\x04\r\x03\x01\x03\0\x01\x12\x04\x81\x01\x0c\
    \x15\n\x10\n\x08\x04\r\x03\x01\x03\0\x02\0\x12\x04\x82\x01\x06\x17\n\x11\
    \n\t\x04\r\x03\x01\x03\0\x02\0\x05\x12\x04\x82\x01\x06\x0c\n\x11\n\t\x04\
    \r\x03\x01\x03\0\x02\0\x01\x12\x04\x82\x01\r\x12\n\x11\n\t\x04\r\x03\x01\
    \x03\0\x02\0\x03\x12\x04\x82\x01\x15\x16\n\x10\n\x08\x04\r\x03\x01\x03\0\
    \x02\x01\x12\x04\x83\x01\x06\x1b\n\x11\n\t\x04\r\x03\x01\x03\0\x02\x01\
    \x05\x12\x04\x83\x01\x06\x0c\n\x11\n\t\x04\r\x03\x01\x03\0\x02\x01\x01\
    \x12\x04\x83\x01\r\x16\n\x11\n\t\x04\r\x03\x01\x03\0\x02\x01\x03\x12\x04\
    \x83\x01\x19\x1a\n\x0c\n\x04\x04\r\x02\0\x12\x04\x87\x01\x02%\n\r\n\x05\
    \x04\r\x02\0\x06\x12\x04\x87\x01\x02\x10\n\r\n\x05\x04\r\x02\0\x01\x12\
    \x04\x87\x01\x11\x20\n\r\n\x05\x04\r\x02\0\x03\x12\x04\x87\x01#$\n\x0c\n\
    \x04\x04\r\x02\x01\x12\x04\x88\x01\x02\x1a\n\r\n\x05\x04\r\x02\x01\x06\
    \x12\x04\x88\x01\x02\x0b\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\x88\x01\x0c\
    \x15\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\x88\x01\x18\x19\n\x0c\n\x02\x04\
    \x0e\x12\x06\x8b\x01\0\x96\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\x8b\
    \x01\x08\x11\n\x0e\n\x04\x04\x0e\x03\0\x12\x06\x8c\x01\x02\x91\x01\x03\n\
    \r\n\x05\x04\x0e\x03\0\x01\x12\x04\x8c\x01\n\x18\n\x0e\n\x06\x04\x0e\x03\
    \0\x02\0\x12\x04\x8d\x01\x04\x14\n\x0f\n\x07\x04\x0e\x03\0\x02\0\x05\x12\
    \x04\x8d\x01\x04\n\n\x0f\n\x07\x04\x0e\x03\0\x02\0\x01\x12\x04\x8d\x01\
    \x0b\x0f\n\x0f\n\x07\x04\x0e\x03\0\x02\0\x03\x12\x04\x8d\x01\x12\x13\n\
    \x0e\n\x06\x04\x0e\x03\0\x02\x01\x12\x04\x8e\x01\x04\x18\n\x0f\n\x07\x04\
    \x0e\x03\0\x02\x01\x05\x12\x04\x8e\x01\x04\n\n\x0f\n\x07\x04\x0e\x03\0\
    \x02\x01\x01\x12\x04\x8e\x01\x0b\x13\n\x0f\n\x07\x04\x0e\x03\0\x02\x01\
    \x03\x12\x04\x8e\x01\x16\x17\n\x0e\n\x06\x04\x0e\x03\0\x02\x02\x12\x04\
    \x8f\x01\x04\x18\n\x0f\n\x07\x04\x0e\x03\0\x02\x02\x05\x12\x04\x8f\x01\
    \x04\n\n\x0f\n\x07\x04\x0e\x03\0\x02\x02\x01\x12\x04\x8f\x01\x0b\x13\n\
    \x0f\n\x07\x04\x0e\x03\0\x02\x02\x03\x12\x04\x8f\x01\x16\x17\n\x0e\n\x06\
    \x04\x0e\x03\0\x02\x03\x12\x04\x90\x01\x04\x11\n\x0f\n\x07\x04\x0e\x03\0\
    \x02\x03\x05\x12\x04\x90\x01\x04\x08\n\x0f\n\x07\x04\x0e\x03\0\x02\x03\
    \x01\x12\x04\x90\x01\t\x0c\n\x0f\n\x07\x04\x0e\x03\0\x02\x03\x03\x12\x04\
    \x90\x01\x0f\x10\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\x93\x01\x02%\n\r\n\
    \x05\x04\x0e\x02\0\x06\x12\x04\x93\x01\x02\x10\n\r\n\x05\x04\x0e\x02\0\
    \x01\x12\x04\x93\x01\x11\x20\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x93\x01\
    #$\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\x94\x01\x02\x19\n\r\n\x05\x04\x0e\
    \x02\x01\x06\x12\x04\x94\x01\x02\x06\n\r\n\x05\x04\x0e\x02\x01\x01\x12\
    \x04\x94\x01\x07\x14\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\x94\x01\x17\
    \x18\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\x95\x01\x02\x1b\n\r\n\x05\x04\
    \x0e\x02\x02\x06\x12\x04\x95\x01\x02\x06\n\r\n\x05\x04\x0e\x02\x02\x01\
    \x12\x04\x95\x01\x07\x16\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\x95\x01\
    \x19\x1a\nP\n\x02\x05\0\x12\x06\x9b\x01\0\xa0\x01\x01\x1aB*\nStream\x20G\
    raph\x20Status.\x20It\x20shows\x20which\x20status\x20a\x20stream\x20job\
    \x20is\x20now.\n\n\x0b\n\x03\x05\0\x01\x12\x04\x9b\x01\x05\x13\n\x0c\n\
    \x04\x05\0\x02\0\x12\x04\x9c\x01\x02\x12\n\r\n\x05\x05\0\x02\0\x01\x12\
    \x04\x9c\x01\x02\r\n\r\n\x05\x05\0\x02\0\x02\x12\x04\x9c\x01\x10\x11\n\
    \x0c\n\x04\x05\0\x02\x01\x12\x04\x9d\x01\x02\x0e\n\r\n\x05\x05\0\x02\x01\
    \x01\x12\x04\x9d\x01\x02\t\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\x9d\x01\
    \x0c\r\n\x0c\n\x04\x05\0\x02\x02\x12\x04\x9e\x01\x02\x0e\n\r\n\x05\x05\0\
    \x02\x02\x01\x12\x04\x9e\x01\x02\t\n\r\n\x05\x05\0\x02\x02\x02\x12\x04\
    \x9e\x01\x0c\r\n\x0c\n\x04\x05\0\x02\x03\x12\x04\x9f\x01\x02\r\n\r\n\x05\
    \x05\0\x02\x03\x01\x12\x04\x9f\x01\x02\x08\n\r\n\x05\x05\0\x02\x03\x02\
    \x12\x04\x9f\x01\x0b\x0c\n\x0c\n\x02\x04\x0f\x12\x06\xa2\x01\0\xa6\x01\
    \x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xa2\x01\x08\x10\nS\n\x04\x04\x0f\
    \x02\0\x12\x04\xa3\x01\x02\x1f\"E\x20job\x20id,\x20for\x20now\x20it\x20i\
    s\x20which\x20table\x20the\x20stream\x20graph\x20output\x20will\x20sink\
    \n\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\xa3\x01\x02\x13\n\r\n\x05\x04\x0f\
    \x02\0\x01\x12\x04\xa3\x01\x14\x1a\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\
    \xa3\x01\x1d\x1e\n\x1f\n\x04\x04\x0f\x02\x01\x12\x04\xa4\x01\x02(\"\x11\
    \x20graph\x20structure\n\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xa4\x01\
    \x02\n\n\r\n\x05\x04\x0f\x02\x01\x06\x12\x04\xa4\x01\x0b\x1e\n\r\n\x05\
    \x04\x0f\x02\x01\x01\x12\x04\xa4\x01\x1f#\n\r\n\x05\x04\x0f\x02\x01\x03\
    \x12\x04\xa4\x01&'\n\x20\n\x04\x04\x0f\x02\x02\x12\x04\xa5\x01\x02-\"\
    \x12\x20details\x20of\x20nodes\n\n\r\n\x05\x04\x0f\x02\x02\x06\x12\x04\
    \xa5\x01\x02\"\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\xa5\x01#(\n\r\n\x05\
    \x04\x0f\x02\x02\x03\x12\x04\xa5\x01+,\n\x0c\n\x02\x04\x10\x12\x06\xa8\
    \x01\0\xab\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xa8\x01\x08\x14\n\x0c\
    \n\x04\x04\x10\x02\0\x12\x04\xa9\x01\x02\x14\n\r\n\x05\x04\x10\x02\0\x06\
    \x12\x04\xa9\x01\x02\x08\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xa9\x01\t\
    \x0f\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xa9\x01\x12\x13\n\x0c\n\x04\x04\
    \x10\x02\x01\x12\x04\xaa\x01\x02\x16\n\r\n\x05\x04\x10\x02\x01\x06\x12\
    \x04\xaa\x01\x02\t\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xaa\x01\n\x11\n\
    \r\n\x05\x04\x10\x02\x01\x03\x12\x04\xaa\x01\x14\x15\n\x0c\n\x02\x04\x11\
    \x12\x06\xad\x01\0\xc0\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xad\x01\
    \x08\x0e\n\x0e\n\x04\x04\x11\x08\0\x12\x06\xae\x01\x02\xb2\x01\x03\n\r\n\
    \x05\x04\x11\x08\0\x01\x12\x04\xae\x01\x08\r\n\x0c\n\x04\x04\x11\x02\0\
    \x12\x04\xaf\x01\x04\x1a\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xaf\x01\x04\
    \x0f\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xaf\x01\x10\x15\n\r\n\x05\x04\
    \x11\x02\0\x03\x12\x04\xaf\x01\x18\x19\n\x0c\n\x04\x04\x11\x02\x01\x12\
    \x04\xb0\x01\x04\x1c\n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\xb0\x01\x04\
    \x11\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xb0\x01\x12\x17\n\r\n\x05\x04\
    \x11\x02\x01\x03\x12\x04\xb0\x01\x1a\x1b\n\x0c\n\x04\x04\x11\x02\x02\x12\
    \x04\xb1\x01\x04\x1e\n\r\n\x05\x04\x11\x02\x02\x06\x12\x04\xb1\x01\x04\
    \x11\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xb1\x01\x12\x19\n\r\n\x05\x04\
    \x11\x02\x02\x03\x12\x04\xb1\x01\x1c\x1d\n\x0e\n\x04\x04\x11\x03\0\x12\
    \x06\xb4\x01\x02\xb6\x01\x03\n\r\n\x05\x04\x11\x03\0\x01\x12\x04\xb4\x01\
    \n\x15\n1\n\x06\x04\x11\x03\0\x02\0\x12\x04\xb5\x01\x04\x19\"!\x20Only\
    \x20for\x20sliding\x20&\x20fixed\x20window\n\n\x0f\n\x07\x04\x11\x03\0\
    \x02\0\x06\x12\x04\xb5\x01\x04\x0f\n\x0f\n\x07\x04\x11\x03\0\x02\0\x01\
    \x12\x04\xb5\x01\x10\x14\n\x0f\n\x07\x04\x11\x03\0\x02\0\x03\x12\x04\xb5\
    \x01\x17\x18\n\x0e\n\x04\x04\x11\x03\x01\x12\x06\xb8\x01\x02\xbb\x01\x03\
    \n\r\n\x05\x04\x11\x03\x01\x01\x12\x04\xb8\x01\n\x17\n\x0e\n\x06\x04\x11\
    \x03\x01\x02\0\x12\x04\xb9\x01\x04\x19\n\x0f\n\x07\x04\x11\x03\x01\x02\0\
    \x06\x12\x04\xb9\x01\x04\x0f\n\x0f\n\x07\x04\x11\x03\x01\x02\0\x01\x12\
    \x04\xb9\x01\x10\x14\n\x0f\n\x07\x04\x11\x03\x01\x02\0\x03\x12\x04\xb9\
    \x01\x17\x18\n\x0e\n\x06\x04\x11\x03\x01\x02\x01\x12\x04\xba\x01\x04\x1b\
    \n\x0f\n\x07\x04\x11\x03\x01\x02\x01\x06\x12\x04\xba\x01\x04\x0f\n\x0f\n\
    \x07\x04\x11\x03\x01\x02\x01\x01\x12\x04\xba\x01\x10\x16\n\x0f\n\x07\x04\
    \x11\x03\x01\x02\x01\x03\x12\x04\xba\x01\x19\x1a\n\x0e\n\x04\x04\x11\x03\
    \x02\x12\x06\xbd\x01\x02\xbf\x01\x03\n\r\n\x05\x04\x11\x03\x02\x01\x12\
    \x04\xbd\x01\n\x17\n)\n\x06\x04\x11\x03\x02\x02\0\x12\x04\xbe\x01\x04\
    \x1c\"\x19\x20Only\x20for\x20Session\x20Window\n\n\x0f\n\x07\x04\x11\x03\
    \x02\x02\0\x06\x12\x04\xbe\x01\x04\x0f\n\x0f\n\x07\x04\x11\x03\x02\x02\0\
    \x01\x12\x04\xbe\x01\x10\x17\n\x0f\n\x07\x04\x11\x03\x02\x02\0\x03\x12\
    \x04\xbe\x01\x1a\x1b\n\x0c\n\x02\x04\x12\x12\x06\xc2\x01\0\xca\x01\x01\n\
    \x0b\n\x03\x04\x12\x01\x12\x04\xc2\x01\x08\x0f\n\x0e\n\x04\x04\x12\x08\0\
    \x12\x06\xc3\x01\x02\xc5\x01\x03\n\r\n\x05\x04\x12\x08\0\x01\x12\x04\xc3\
    \x01\x08\r\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xc4\x01\x04\x1c\n\r\n\x05\
    \x04\x12\x02\0\x06\x12\x04\xc4\x01\x04\r\n\r\n\x05\x04\x12\x02\0\x01\x12\
    \x04\xc4\x01\x0e\x17\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xc4\x01\x1a\x1b\
    \n\x0e\n\x04\x04\x12\x03\0\x12\x06\xc7\x01\x02\xc9\x01\x03\n\r\n\x05\x04\
    \x12\x03\0\x01\x12\x04\xc7\x01\n\x13\n\x0e\n\x06\x04\x12\x03\0\x02\0\x12\
    \x04\xc8\x01\x04\x1e\n\x0f\n\x07\x04\x12\x03\0\x02\0\x06\x12\x04\xc8\x01\
    \x04\x0f\n\x0f\n\x07\x04\x12\x03\0\x02\0\x01\x12\x04\xc8\x01\x10\x19\n\
    \x0f\n\x07\x04\x12\x03\0\x02\0\x03\x12\x04\xc8\x01\x1c\x1db\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
