// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `common/stream.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct DataflowMeta {
    // message fields
    pub center: u32,
    pub neighbors: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataflowMeta {
    fn default() -> &'a DataflowMeta {
        <DataflowMeta as ::protobuf::Message>::default_instance()
    }
}

impl DataflowMeta {
    pub fn new() -> DataflowMeta {
        ::std::default::Default::default()
    }

    // uint32 center = 1;


    pub fn get_center(&self) -> u32 {
        self.center
    }
    pub fn clear_center(&mut self) {
        self.center = 0;
    }

    // Param is passed by value, moved
    pub fn set_center(&mut self, v: u32) {
        self.center = v;
    }

    // repeated uint32 neighbors = 2;


    pub fn get_neighbors(&self) -> &[u32] {
        &self.neighbors
    }
    pub fn clear_neighbors(&mut self) {
        self.neighbors.clear();
    }

    // Param is passed by value, moved
    pub fn set_neighbors(&mut self, v: ::std::vec::Vec<u32>) {
        self.neighbors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_neighbors(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.neighbors
    }

    // Take field
    pub fn take_neighbors(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.neighbors, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DataflowMeta {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.center = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.neighbors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.center != 0 {
            my_size += ::protobuf::rt::value_size(1, self.center, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.neighbors {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.center != 0 {
            os.write_uint32(1, self.center)?;
        }
        for v in &self.neighbors {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataflowMeta {
        DataflowMeta::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "center",
                |m: &DataflowMeta| { &m.center },
                |m: &mut DataflowMeta| { &mut m.center },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "neighbors",
                |m: &DataflowMeta| { &m.neighbors },
                |m: &mut DataflowMeta| { &mut m.neighbors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataflowMeta>(
                "DataflowMeta",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataflowMeta {
        static instance: ::protobuf::rt::LazyV2<DataflowMeta> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataflowMeta::new)
    }
}

impl ::protobuf::Clear for DataflowMeta {
    fn clear(&mut self) {
        self.center = 0;
        self.neighbors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataflowMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataflowMeta {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperatorInfo {
    // message fields
    pub field_type: OperatorType,
    pub table_id: u32,
    pub header_id: u32,
    pub values: ::protobuf::RepeatedField<ConstOp>,
    pub connector: ::protobuf::SingularPtrField<Connector>,
    pub host_addr: ::protobuf::SingularPtrField<super::common::HostAddr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OperatorInfo {
    fn default() -> &'a OperatorInfo {
        <OperatorInfo as ::protobuf::Message>::default_instance()
    }
}

impl OperatorInfo {
    pub fn new() -> OperatorInfo {
        ::std::default::Default::default()
    }

    // .common.OperatorType type = 1;


    pub fn get_field_type(&self) -> OperatorType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = OperatorType::REFERENCE;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: OperatorType) {
        self.field_type = v;
    }

    // uint32 table_id = 2;


    pub fn get_table_id(&self) -> u32 {
        self.table_id
    }
    pub fn clear_table_id(&mut self) {
        self.table_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_table_id(&mut self, v: u32) {
        self.table_id = v;
    }

    // uint32 header_id = 3;


    pub fn get_header_id(&self) -> u32 {
        self.header_id
    }
    pub fn clear_header_id(&mut self) {
        self.header_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_header_id(&mut self, v: u32) {
        self.header_id = v;
    }

    // repeated .common.ConstOp values = 4;


    pub fn get_values(&self) -> &[ConstOp] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<ConstOp>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<ConstOp> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<ConstOp> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }

    // .common.Connector connector = 5;


    pub fn get_connector(&self) -> &Connector {
        self.connector.as_ref().unwrap_or_else(|| <Connector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_connector(&mut self) {
        self.connector.clear();
    }

    pub fn has_connector(&self) -> bool {
        self.connector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connector(&mut self, v: Connector) {
        self.connector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connector(&mut self) -> &mut Connector {
        if self.connector.is_none() {
            self.connector.set_default();
        }
        self.connector.as_mut().unwrap()
    }

    // Take field
    pub fn take_connector(&mut self) -> Connector {
        self.connector.take().unwrap_or_else(|| Connector::new())
    }

    // .common.HostAddr host_addr = 6;


    pub fn get_host_addr(&self) -> &super::common::HostAddr {
        self.host_addr.as_ref().unwrap_or_else(|| <super::common::HostAddr as ::protobuf::Message>::default_instance())
    }
    pub fn clear_host_addr(&mut self) {
        self.host_addr.clear();
    }

    pub fn has_host_addr(&self) -> bool {
        self.host_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_addr(&mut self, v: super::common::HostAddr) {
        self.host_addr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_addr(&mut self) -> &mut super::common::HostAddr {
        if self.host_addr.is_none() {
            self.host_addr.set_default();
        }
        self.host_addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_addr(&mut self) -> super::common::HostAddr {
        self.host_addr.take().unwrap_or_else(|| super::common::HostAddr::new())
    }
}

impl ::protobuf::Message for OperatorInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.values {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.connector {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.host_addr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.table_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.header_id = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.values)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connector)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.host_addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != OperatorType::REFERENCE {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.table_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.table_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.header_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.header_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.connector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.host_addr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != OperatorType::REFERENCE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.table_id != 0 {
            os.write_uint32(2, self.table_id)?;
        }
        if self.header_id != 0 {
            os.write_uint32(3, self.header_id)?;
        }
        for v in &self.values {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.connector.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.host_addr.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperatorInfo {
        OperatorInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OperatorType>>(
                "type",
                |m: &OperatorInfo| { &m.field_type },
                |m: &mut OperatorInfo| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "table_id",
                |m: &OperatorInfo| { &m.table_id },
                |m: &mut OperatorInfo| { &mut m.table_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "header_id",
                |m: &OperatorInfo| { &m.header_id },
                |m: &mut OperatorInfo| { &mut m.header_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConstOp>>(
                "values",
                |m: &OperatorInfo| { &m.values },
                |m: &mut OperatorInfo| { &mut m.values },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Connector>>(
                "connector",
                |m: &OperatorInfo| { &m.connector },
                |m: &mut OperatorInfo| { &mut m.connector },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::HostAddr>>(
                "host_addr",
                |m: &OperatorInfo| { &m.host_addr },
                |m: &mut OperatorInfo| { &mut m.host_addr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OperatorInfo>(
                "OperatorInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OperatorInfo {
        static instance: ::protobuf::rt::LazyV2<OperatorInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OperatorInfo::new)
    }
}

impl ::protobuf::Clear for OperatorInfo {
    fn clear(&mut self) {
        self.field_type = OperatorType::REFERENCE;
        self.table_id = 0;
        self.header_id = 0;
        self.values.clear();
        self.connector.clear();
        self.host_addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperatorInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperatorInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConstOp {
    // message fields
    pub value: ::std::vec::Vec<u8>,
    pub node_id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConstOp {
    fn default() -> &'a ConstOp {
        <ConstOp as ::protobuf::Message>::default_instance()
    }
}

impl ConstOp {
    pub fn new() -> ConstOp {
        ::std::default::Default::default()
    }

    // bytes value = 1;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // uint32 node_id = 2;


    pub fn get_node_id(&self) -> u32 {
        self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u32) {
        self.node_id = v;
    }
}

impl ::protobuf::Message for ConstOp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.node_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.value);
        }
        if self.node_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.node_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_bytes(1, &self.value)?;
        }
        if self.node_id != 0 {
            os.write_uint32(2, self.node_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConstOp {
        ConstOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &ConstOp| { &m.value },
                |m: &mut ConstOp| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "node_id",
                |m: &ConstOp| { &m.node_id },
                |m: &mut ConstOp| { &mut m.node_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConstOp>(
                "ConstOp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConstOp {
        static instance: ::protobuf::rt::LazyV2<ConstOp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConstOp::new)
    }
}

impl ::protobuf::Clear for ConstOp {
    fn clear(&mut self) {
        self.value.clear();
        self.node_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConstOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConstOp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Connector {
    // message fields
    pub field_type: ConnectorTypeEnum,
    pub connector_basic: ::protobuf::SingularPtrField<ConnectionBasic>,
    pub options: ::protobuf::SingularPtrField<Options>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Connector {
    fn default() -> &'a Connector {
        <Connector as ::protobuf::Message>::default_instance()
    }
}

impl Connector {
    pub fn new() -> Connector {
        ::std::default::Default::default()
    }

    // .common.ConnectorTypeEnum type = 1;


    pub fn get_field_type(&self) -> ConnectorTypeEnum {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ConnectorTypeEnum::KAFKA;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ConnectorTypeEnum) {
        self.field_type = v;
    }

    // .common.ConnectionBasic connector_basic = 2;


    pub fn get_connector_basic(&self) -> &ConnectionBasic {
        self.connector_basic.as_ref().unwrap_or_else(|| <ConnectionBasic as ::protobuf::Message>::default_instance())
    }
    pub fn clear_connector_basic(&mut self) {
        self.connector_basic.clear();
    }

    pub fn has_connector_basic(&self) -> bool {
        self.connector_basic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connector_basic(&mut self, v: ConnectionBasic) {
        self.connector_basic = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connector_basic(&mut self) -> &mut ConnectionBasic {
        if self.connector_basic.is_none() {
            self.connector_basic.set_default();
        }
        self.connector_basic.as_mut().unwrap()
    }

    // Take field
    pub fn take_connector_basic(&mut self) -> ConnectionBasic {
        self.connector_basic.take().unwrap_or_else(|| ConnectionBasic::new())
    }

    // .common.Options options = 3;


    pub fn get_options(&self) -> &Options {
        self.options.as_ref().unwrap_or_else(|| <Options as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: Options) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut Options {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> Options {
        self.options.take().unwrap_or_else(|| Options::new())
    }
}

impl ::protobuf::Message for Connector {
    fn is_initialized(&self) -> bool {
        for v in &self.connector_basic {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connector_basic)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != ConnectorTypeEnum::KAFKA {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if let Some(ref v) = self.connector_basic.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != ConnectorTypeEnum::KAFKA {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.connector_basic.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Connector {
        Connector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConnectorTypeEnum>>(
                "type",
                |m: &Connector| { &m.field_type },
                |m: &mut Connector| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConnectionBasic>>(
                "connector_basic",
                |m: &Connector| { &m.connector_basic },
                |m: &mut Connector| { &mut m.connector_basic },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Options>>(
                "options",
                |m: &Connector| { &m.options },
                |m: &mut Connector| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Connector>(
                "Connector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Connector {
        static instance: ::protobuf::rt::LazyV2<Connector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Connector::new)
    }
}

impl ::protobuf::Clear for Connector {
    fn clear(&mut self) {
        self.field_type = ConnectorTypeEnum::KAFKA;
        self.connector_basic.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Connector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Connector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectionBasic {
    // message fields
    pub uri: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectionBasic {
    fn default() -> &'a ConnectionBasic {
        <ConnectionBasic as ::protobuf::Message>::default_instance()
    }
}

impl ConnectionBasic {
    pub fn new() -> ConnectionBasic {
        ::std::default::Default::default()
    }

    // string uri = 1;


    pub fn get_uri(&self) -> &str {
        &self.uri
    }
    pub fn clear_uri(&mut self) {
        self.uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        &mut self.uri
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uri, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConnectionBasic {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uri)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uri);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uri.is_empty() {
            os.write_string(1, &self.uri)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectionBasic {
        ConnectionBasic::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uri",
                |m: &ConnectionBasic| { &m.uri },
                |m: &mut ConnectionBasic| { &mut m.uri },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnectionBasic>(
                "ConnectionBasic",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConnectionBasic {
        static instance: ::protobuf::rt::LazyV2<ConnectionBasic> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConnectionBasic::new)
    }
}

impl ::protobuf::Clear for ConnectionBasic {
    fn clear(&mut self) {
        self.uri.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectionBasic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectionBasic {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Options {
    // message fields
    pub qe_opts: ::protobuf::SingularPtrField<QueryEngineOptions>,
    pub kafka_opts: ::protobuf::SingularPtrField<KafkaOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Options {
    fn default() -> &'a Options {
        <Options as ::protobuf::Message>::default_instance()
    }
}

impl Options {
    pub fn new() -> Options {
        ::std::default::Default::default()
    }

    // .common.QueryEngineOptions qe_opts = 1;


    pub fn get_qe_opts(&self) -> &QueryEngineOptions {
        self.qe_opts.as_ref().unwrap_or_else(|| <QueryEngineOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_qe_opts(&mut self) {
        self.qe_opts.clear();
    }

    pub fn has_qe_opts(&self) -> bool {
        self.qe_opts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qe_opts(&mut self, v: QueryEngineOptions) {
        self.qe_opts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_qe_opts(&mut self) -> &mut QueryEngineOptions {
        if self.qe_opts.is_none() {
            self.qe_opts.set_default();
        }
        self.qe_opts.as_mut().unwrap()
    }

    // Take field
    pub fn take_qe_opts(&mut self) -> QueryEngineOptions {
        self.qe_opts.take().unwrap_or_else(|| QueryEngineOptions::new())
    }

    // .common.KafkaOptions kafka_opts = 2;


    pub fn get_kafka_opts(&self) -> &KafkaOptions {
        self.kafka_opts.as_ref().unwrap_or_else(|| <KafkaOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_kafka_opts(&mut self) {
        self.kafka_opts.clear();
    }

    pub fn has_kafka_opts(&self) -> bool {
        self.kafka_opts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kafka_opts(&mut self, v: KafkaOptions) {
        self.kafka_opts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kafka_opts(&mut self) -> &mut KafkaOptions {
        if self.kafka_opts.is_none() {
            self.kafka_opts.set_default();
        }
        self.kafka_opts.as_mut().unwrap()
    }

    // Take field
    pub fn take_kafka_opts(&mut self) -> KafkaOptions {
        self.kafka_opts.take().unwrap_or_else(|| KafkaOptions::new())
    }
}

impl ::protobuf::Message for Options {
    fn is_initialized(&self) -> bool {
        for v in &self.qe_opts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kafka_opts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.qe_opts)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.kafka_opts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.qe_opts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.kafka_opts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.qe_opts.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.kafka_opts.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Options {
        Options::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryEngineOptions>>(
                "qe_opts",
                |m: &Options| { &m.qe_opts },
                |m: &mut Options| { &mut m.qe_opts },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KafkaOptions>>(
                "kafka_opts",
                |m: &Options| { &m.kafka_opts },
                |m: &mut Options| { &mut m.kafka_opts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Options>(
                "Options",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Options {
        static instance: ::protobuf::rt::LazyV2<Options> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Options::new)
    }
}

impl ::protobuf::Clear for Options {
    fn clear(&mut self) {
        self.qe_opts.clear();
        self.kafka_opts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Options {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Options {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KafkaOptions {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KafkaOptions {
    fn default() -> &'a KafkaOptions {
        <KafkaOptions as ::protobuf::Message>::default_instance()
    }
}

impl KafkaOptions {
    pub fn new() -> KafkaOptions {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for KafkaOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KafkaOptions {
        KafkaOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KafkaOptions>(
                "KafkaOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KafkaOptions {
        static instance: ::protobuf::rt::LazyV2<KafkaOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KafkaOptions::new)
    }
}

impl ::protobuf::Clear for KafkaOptions {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KafkaOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KafkaOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryEngineOptions {
    // message fields
    pub interval: u32,
    pub batch_size: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryEngineOptions {
    fn default() -> &'a QueryEngineOptions {
        <QueryEngineOptions as ::protobuf::Message>::default_instance()
    }
}

impl QueryEngineOptions {
    pub fn new() -> QueryEngineOptions {
        ::std::default::Default::default()
    }

    // uint32 interval = 1;


    pub fn get_interval(&self) -> u32 {
        self.interval
    }
    pub fn clear_interval(&mut self) {
        self.interval = 0;
    }

    // Param is passed by value, moved
    pub fn set_interval(&mut self, v: u32) {
        self.interval = v;
    }

    // uint32 batch_size = 2;


    pub fn get_batch_size(&self) -> u32 {
        self.batch_size
    }
    pub fn clear_batch_size(&mut self) {
        self.batch_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_batch_size(&mut self, v: u32) {
        self.batch_size = v;
    }
}

impl ::protobuf::Message for QueryEngineOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.interval = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.batch_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.interval != 0 {
            my_size += ::protobuf::rt::value_size(1, self.interval, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.batch_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.batch_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.interval != 0 {
            os.write_uint32(1, self.interval)?;
        }
        if self.batch_size != 0 {
            os.write_uint32(2, self.batch_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryEngineOptions {
        QueryEngineOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "interval",
                |m: &QueryEngineOptions| { &m.interval },
                |m: &mut QueryEngineOptions| { &mut m.interval },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "batch_size",
                |m: &QueryEngineOptions| { &m.batch_size },
                |m: &mut QueryEngineOptions| { &mut m.batch_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryEngineOptions>(
                "QueryEngineOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryEngineOptions {
        static instance: ::protobuf::rt::LazyV2<QueryEngineOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryEngineOptions::new)
    }
}

impl ::protobuf::Clear for QueryEngineOptions {
    fn clear(&mut self) {
        self.interval = 0;
        self.batch_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryEngineOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryEngineOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Dataflow {
    // message fields
    pub job_id: ::protobuf::SingularPtrField<super::common::JobId>,
    pub meta: ::protobuf::RepeatedField<DataflowMeta>,
    pub nodes: ::std::collections::HashMap<u32, OperatorInfo>,
    pub config: ::protobuf::SingularPtrField<DataflowConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Dataflow {
    fn default() -> &'a Dataflow {
        <Dataflow as ::protobuf::Message>::default_instance()
    }
}

impl Dataflow {
    pub fn new() -> Dataflow {
        ::std::default::Default::default()
    }

    // .common.JobId job_id = 1;


    pub fn get_job_id(&self) -> &super::common::JobId {
        self.job_id.as_ref().unwrap_or_else(|| <super::common::JobId as ::protobuf::Message>::default_instance())
    }
    pub fn clear_job_id(&mut self) {
        self.job_id.clear();
    }

    pub fn has_job_id(&self) -> bool {
        self.job_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_job_id(&mut self, v: super::common::JobId) {
        self.job_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_job_id(&mut self) -> &mut super::common::JobId {
        if self.job_id.is_none() {
            self.job_id.set_default();
        }
        self.job_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_job_id(&mut self) -> super::common::JobId {
        self.job_id.take().unwrap_or_else(|| super::common::JobId::new())
    }

    // repeated .common.DataflowMeta meta = 2;


    pub fn get_meta(&self) -> &[DataflowMeta] {
        &self.meta
    }
    pub fn clear_meta(&mut self) {
        self.meta.clear();
    }

    // Param is passed by value, moved
    pub fn set_meta(&mut self, v: ::protobuf::RepeatedField<DataflowMeta>) {
        self.meta = v;
    }

    // Mutable pointer to the field.
    pub fn mut_meta(&mut self) -> &mut ::protobuf::RepeatedField<DataflowMeta> {
        &mut self.meta
    }

    // Take field
    pub fn take_meta(&mut self) -> ::protobuf::RepeatedField<DataflowMeta> {
        ::std::mem::replace(&mut self.meta, ::protobuf::RepeatedField::new())
    }

    // repeated .common.Dataflow.NodesEntry nodes = 3;


    pub fn get_nodes(&self) -> &::std::collections::HashMap<u32, OperatorInfo> {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::std::collections::HashMap<u32, OperatorInfo>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::std::collections::HashMap<u32, OperatorInfo> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::std::collections::HashMap<u32, OperatorInfo> {
        ::std::mem::replace(&mut self.nodes, ::std::collections::HashMap::new())
    }

    // .common.DataflowConfig config = 4;


    pub fn get_config(&self) -> &DataflowConfig {
        self.config.as_ref().unwrap_or_else(|| <DataflowConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: DataflowConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut DataflowConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> DataflowConfig {
        self.config.take().unwrap_or_else(|| DataflowConfig::new())
    }
}

impl ::protobuf::Message for Dataflow {
    fn is_initialized(&self) -> bool {
        for v in &self.job_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.meta {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.job_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.meta)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<OperatorInfo>>(wire_type, is, &mut self.nodes)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.job_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.meta {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<OperatorInfo>>(3, &self.nodes);
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.job_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.meta {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<OperatorInfo>>(3, &self.nodes, os)?;
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Dataflow {
        Dataflow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::JobId>>(
                "job_id",
                |m: &Dataflow| { &m.job_id },
                |m: &mut Dataflow| { &mut m.job_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataflowMeta>>(
                "meta",
                |m: &Dataflow| { &m.meta },
                |m: &mut Dataflow| { &mut m.meta },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint32, ::protobuf::types::ProtobufTypeMessage<OperatorInfo>>(
                "nodes",
                |m: &Dataflow| { &m.nodes },
                |m: &mut Dataflow| { &mut m.nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataflowConfig>>(
                "config",
                |m: &Dataflow| { &m.config },
                |m: &mut Dataflow| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Dataflow>(
                "Dataflow",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Dataflow {
        static instance: ::protobuf::rt::LazyV2<Dataflow> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Dataflow::new)
    }
}

impl ::protobuf::Clear for Dataflow {
    fn clear(&mut self) {
        self.job_id.clear();
        self.meta.clear();
        self.nodes.clear();
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Dataflow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dataflow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DataflowConfig {
    // message fields
    pub window: ::protobuf::SingularPtrField<WindowConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataflowConfig {
    fn default() -> &'a DataflowConfig {
        <DataflowConfig as ::protobuf::Message>::default_instance()
    }
}

impl DataflowConfig {
    pub fn new() -> DataflowConfig {
        ::std::default::Default::default()
    }

    // .common.WindowConfig window = 1;


    pub fn get_window(&self) -> &WindowConfig {
        self.window.as_ref().unwrap_or_else(|| <WindowConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_window(&mut self) {
        self.window.clear();
    }

    pub fn has_window(&self) -> bool {
        self.window.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window(&mut self, v: WindowConfig) {
        self.window = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_window(&mut self) -> &mut WindowConfig {
        if self.window.is_none() {
            self.window.set_default();
        }
        self.window.as_mut().unwrap()
    }

    // Take field
    pub fn take_window(&mut self) -> WindowConfig {
        self.window.take().unwrap_or_else(|| WindowConfig::new())
    }
}

impl ::protobuf::Message for DataflowConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.window {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.window)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.window.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.window.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataflowConfig {
        DataflowConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WindowConfig>>(
                "window",
                |m: &DataflowConfig| { &m.window },
                |m: &mut DataflowConfig| { &mut m.window },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataflowConfig>(
                "DataflowConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataflowConfig {
        static instance: ::protobuf::rt::LazyV2<DataflowConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataflowConfig::new)
    }
}

impl ::protobuf::Clear for DataflowConfig {
    fn clear(&mut self) {
        self.window.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataflowConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataflowConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WindowConfig {
    // message fields
    pub field_type: WindowType,
    pub size: u32,
    pub period: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WindowConfig {
    fn default() -> &'a WindowConfig {
        <WindowConfig as ::protobuf::Message>::default_instance()
    }
}

impl WindowConfig {
    pub fn new() -> WindowConfig {
        ::std::default::Default::default()
    }

    // .common.WindowType type = 1;


    pub fn get_field_type(&self) -> WindowType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = WindowType::FIXED;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: WindowType) {
        self.field_type = v;
    }

    // uint32 size = 2;


    pub fn get_size(&self) -> u32 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = v;
    }

    // uint32 period = 3;


    pub fn get_period(&self) -> u32 {
        self.period
    }
    pub fn clear_period(&mut self) {
        self.period = 0;
    }

    // Param is passed by value, moved
    pub fn set_period(&mut self, v: u32) {
        self.period = v;
    }
}

impl ::protobuf::Message for WindowConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.period = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != WindowType::FIXED {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.period != 0 {
            my_size += ::protobuf::rt::value_size(3, self.period, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != WindowType::FIXED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.size != 0 {
            os.write_uint32(2, self.size)?;
        }
        if self.period != 0 {
            os.write_uint32(3, self.period)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WindowConfig {
        WindowConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WindowType>>(
                "type",
                |m: &WindowConfig| { &m.field_type },
                |m: &mut WindowConfig| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "size",
                |m: &WindowConfig| { &m.size },
                |m: &mut WindowConfig| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "period",
                |m: &WindowConfig| { &m.period },
                |m: &mut WindowConfig| { &mut m.period },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WindowConfig>(
                "WindowConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WindowConfig {
        static instance: ::protobuf::rt::LazyV2<WindowConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WindowConfig::new)
    }
}

impl ::protobuf::Clear for WindowConfig {
    fn clear(&mut self) {
        self.field_type = WindowType::FIXED;
        self.size = 0;
        self.period = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WindowConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConnectorTypeEnum {
    KAFKA = 0,
    QE = 1,
}

impl ::protobuf::ProtobufEnum for ConnectorTypeEnum {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConnectorTypeEnum> {
        match value {
            0 => ::std::option::Option::Some(ConnectorTypeEnum::KAFKA),
            1 => ::std::option::Option::Some(ConnectorTypeEnum::QE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConnectorTypeEnum] = &[
            ConnectorTypeEnum::KAFKA,
            ConnectorTypeEnum::QE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ConnectorTypeEnum>("ConnectorTypeEnum", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ConnectorTypeEnum {
}

impl ::std::default::Default for ConnectorTypeEnum {
    fn default() -> Self {
        ConnectorTypeEnum::KAFKA
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectorTypeEnum {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OperatorType {
    REFERENCE = 0,
    ADD = 1,
    SUM = 2,
    SUMIF = 3,
    COUNTIF = 4,
    COUNT = 5,
    AVG = 6,
    GROUP = 7,
    GROUPIF = 8,
    MAX = 9,
    MAXIF = 10,
    MIN = 11,
    MINIF = 12,
    SUB = 13,
    MUL = 14,
    DIV = 15,
    EQ = 16,
    NEQ = 17,
    LT = 18,
    GT = 19,
    LTE = 20,
    GTE = 21,
    CONNECTOR = 22,
}

impl ::protobuf::ProtobufEnum for OperatorType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OperatorType> {
        match value {
            0 => ::std::option::Option::Some(OperatorType::REFERENCE),
            1 => ::std::option::Option::Some(OperatorType::ADD),
            2 => ::std::option::Option::Some(OperatorType::SUM),
            3 => ::std::option::Option::Some(OperatorType::SUMIF),
            4 => ::std::option::Option::Some(OperatorType::COUNTIF),
            5 => ::std::option::Option::Some(OperatorType::COUNT),
            6 => ::std::option::Option::Some(OperatorType::AVG),
            7 => ::std::option::Option::Some(OperatorType::GROUP),
            8 => ::std::option::Option::Some(OperatorType::GROUPIF),
            9 => ::std::option::Option::Some(OperatorType::MAX),
            10 => ::std::option::Option::Some(OperatorType::MAXIF),
            11 => ::std::option::Option::Some(OperatorType::MIN),
            12 => ::std::option::Option::Some(OperatorType::MINIF),
            13 => ::std::option::Option::Some(OperatorType::SUB),
            14 => ::std::option::Option::Some(OperatorType::MUL),
            15 => ::std::option::Option::Some(OperatorType::DIV),
            16 => ::std::option::Option::Some(OperatorType::EQ),
            17 => ::std::option::Option::Some(OperatorType::NEQ),
            18 => ::std::option::Option::Some(OperatorType::LT),
            19 => ::std::option::Option::Some(OperatorType::GT),
            20 => ::std::option::Option::Some(OperatorType::LTE),
            21 => ::std::option::Option::Some(OperatorType::GTE),
            22 => ::std::option::Option::Some(OperatorType::CONNECTOR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OperatorType] = &[
            OperatorType::REFERENCE,
            OperatorType::ADD,
            OperatorType::SUM,
            OperatorType::SUMIF,
            OperatorType::COUNTIF,
            OperatorType::COUNT,
            OperatorType::AVG,
            OperatorType::GROUP,
            OperatorType::GROUPIF,
            OperatorType::MAX,
            OperatorType::MAXIF,
            OperatorType::MIN,
            OperatorType::MINIF,
            OperatorType::SUB,
            OperatorType::MUL,
            OperatorType::DIV,
            OperatorType::EQ,
            OperatorType::NEQ,
            OperatorType::LT,
            OperatorType::GT,
            OperatorType::LTE,
            OperatorType::GTE,
            OperatorType::CONNECTOR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OperatorType>("OperatorType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OperatorType {
}

impl ::std::default::Default for OperatorType {
    fn default() -> Self {
        OperatorType::REFERENCE
    }
}

impl ::protobuf::reflect::ProtobufValue for OperatorType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DataflowStatus {
    INITIALIZED = 0,
    RUNNING = 1,
    CLOSING = 2,
    CLOSED = 3,
}

impl ::protobuf::ProtobufEnum for DataflowStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataflowStatus> {
        match value {
            0 => ::std::option::Option::Some(DataflowStatus::INITIALIZED),
            1 => ::std::option::Option::Some(DataflowStatus::RUNNING),
            2 => ::std::option::Option::Some(DataflowStatus::CLOSING),
            3 => ::std::option::Option::Some(DataflowStatus::CLOSED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataflowStatus] = &[
            DataflowStatus::INITIALIZED,
            DataflowStatus::RUNNING,
            DataflowStatus::CLOSING,
            DataflowStatus::CLOSED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataflowStatus>("DataflowStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DataflowStatus {
}

impl ::std::default::Default for DataflowStatus {
    fn default() -> Self {
        DataflowStatus::INITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DataflowStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WindowType {
    FIXED = 0,
    SLIDING = 1,
    SESSION = 2,
}

impl ::protobuf::ProtobufEnum for WindowType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WindowType> {
        match value {
            0 => ::std::option::Option::Some(WindowType::FIXED),
            1 => ::std::option::Option::Some(WindowType::SLIDING),
            2 => ::std::option::Option::Some(WindowType::SESSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WindowType] = &[
            WindowType::FIXED,
            WindowType::SLIDING,
            WindowType::SESSION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<WindowType>("WindowType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for WindowType {
}

impl ::std::default::Default for WindowType {
    fn default() -> Self {
        WindowType::FIXED
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13common/stream.proto\x12\x06common\x1a\x13common/common.proto\"D\n\
    \x0cDataflowMeta\x12\x16\n\x06center\x18\x01\x20\x01(\rR\x06center\x12\
    \x1c\n\tneighbors\x18\x02\x20\x03(\rR\tneighbors\"\xf9\x01\n\x0cOperator\
    Info\x12(\n\x04type\x18\x01\x20\x01(\x0e2\x14.common.OperatorTypeR\x04ty\
    pe\x12\x19\n\x08table_id\x18\x02\x20\x01(\rR\x07tableId\x12\x1b\n\theade\
    r_id\x18\x03\x20\x01(\rR\x08headerId\x12'\n\x06values\x18\x04\x20\x03(\
    \x0b2\x0f.common.ConstOpR\x06values\x12/\n\tconnector\x18\x05\x20\x01(\
    \x0b2\x11.common.ConnectorR\tconnector\x12-\n\thost_addr\x18\x06\x20\x01\
    (\x0b2\x10.common.HostAddrR\x08hostAddr\"8\n\x07ConstOp\x12\x14\n\x05val\
    ue\x18\x01\x20\x01(\x0cR\x05value\x12\x17\n\x07node_id\x18\x02\x20\x01(\
    \rR\x06nodeId\"\xa7\x01\n\tConnector\x12-\n\x04type\x18\x01\x20\x01(\x0e\
    2\x19.common.ConnectorTypeEnumR\x04type\x12@\n\x0fconnector_basic\x18\
    \x02\x20\x01(\x0b2\x17.common.ConnectionBasicR\x0econnectorBasic\x12)\n\
    \x07options\x18\x03\x20\x01(\x0b2\x0f.common.OptionsR\x07options\"#\n\
    \x0fConnectionBasic\x12\x10\n\x03uri\x18\x01\x20\x01(\tR\x03uri\"s\n\x07\
    Options\x123\n\x07qe_opts\x18\x01\x20\x01(\x0b2\x1a.common.QueryEngineOp\
    tionsR\x06qeOpts\x123\n\nkafka_opts\x18\x02\x20\x01(\x0b2\x14.common.Kaf\
    kaOptionsR\tkafkaOpts\"\x0e\n\x0cKafkaOptions\"O\n\x12QueryEngineOptions\
    \x12\x1a\n\x08interval\x18\x01\x20\x01(\rR\x08interval\x12\x1d\n\nbatch_\
    size\x18\x02\x20\x01(\rR\tbatchSize\"\x8d\x02\n\x08Dataflow\x12$\n\x06jo\
    b_id\x18\x01\x20\x01(\x0b2\r.common.JobIdR\x05jobId\x12(\n\x04meta\x18\
    \x02\x20\x03(\x0b2\x14.common.DataflowMetaR\x04meta\x121\n\x05nodes\x18\
    \x03\x20\x03(\x0b2\x1b.common.Dataflow.NodesEntryR\x05nodes\x12.\n\x06co\
    nfig\x18\x04\x20\x01(\x0b2\x16.common.DataflowConfigR\x06config\x1aN\n\n\
    NodesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\rR\x03key\x12*\n\x05value\
    \x18\x02\x20\x01(\x0b2\x14.common.OperatorInfoR\x05value:\x028\x01\">\n\
    \x0eDataflowConfig\x12,\n\x06window\x18\x01\x20\x01(\x0b2\x14.common.Win\
    dowConfigR\x06window\"b\n\x0cWindowConfig\x12&\n\x04type\x18\x01\x20\x01\
    (\x0e2\x12.common.WindowTypeR\x04type\x12\x12\n\x04size\x18\x02\x20\x01(\
    \rR\x04size\x12\x16\n\x06period\x18\x03\x20\x01(\rR\x06period*&\n\x11Con\
    nectorTypeEnum\x12\t\n\x05KAFKA\x10\0\x12\x06\n\x02QE\x10\x01*\xf8\x01\n\
    \x0cOperatorType\x12\r\n\tREFERENCE\x10\0\x12\x07\n\x03ADD\x10\x01\x12\
    \x07\n\x03SUM\x10\x02\x12\t\n\x05SUMIF\x10\x03\x12\x0b\n\x07COUNTIF\x10\
    \x04\x12\t\n\x05COUNT\x10\x05\x12\x07\n\x03AVG\x10\x06\x12\t\n\x05GROUP\
    \x10\x07\x12\x0b\n\x07GROUPIF\x10\x08\x12\x07\n\x03MAX\x10\t\x12\t\n\x05\
    MAXIF\x10\n\x12\x07\n\x03MIN\x10\x0b\x12\t\n\x05MINIF\x10\x0c\x12\x07\n\
    \x03SUB\x10\r\x12\x07\n\x03MUL\x10\x0e\x12\x07\n\x03DIV\x10\x0f\x12\x06\
    \n\x02EQ\x10\x10\x12\x07\n\x03NEQ\x10\x11\x12\x06\n\x02LT\x10\x12\x12\
    \x06\n\x02GT\x10\x13\x12\x07\n\x03LTE\x10\x14\x12\x07\n\x03GTE\x10\x15\
    \x12\r\n\tCONNECTOR\x10\x16*G\n\x0eDataflowStatus\x12\x0f\n\x0bINITIALIZ\
    ED\x10\0\x12\x0b\n\x07RUNNING\x10\x01\x12\x0b\n\x07CLOSING\x10\x02\x12\n\
    \n\x06CLOSED\x10\x03*1\n\nWindowType\x12\t\n\x05FIXED\x10\0\x12\x0b\n\
    \x07SLIDING\x10\x01\x12\x0b\n\x07SESSION\x10\x02B\x07Z\x05protoJ\x97\x1e\
    \n\x06\x12\x04\0\0|\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\
    \x12\x03\x02\0\x0f\n\t\n\x02\x03\0\x12\x03\x03\0\x1d\n\x08\n\x01\x08\x12\
    \x03\x04\0\x1c\n\t\n\x02\x08\x0b\x12\x03\x04\0\x1c\n[\n\x02\x04\0\x12\
    \x04\t\0\x0c\x01\x1aO*\nStreamGraph\x20metadata,\x20it\x20stores\x20the\
    \x20structural\x20information\x20of\x20a\x20stream\x20graph\n\n\n\n\x03\
    \x04\0\x01\x12\x03\t\x08\x14\n\x1d\n\x04\x04\0\x02\0\x12\x03\n\x02\x14\"\
    \x10\x20center\x20node\x20id\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\n\x02\
    \x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\n\t\x0f\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03\n\x12\x13\n!\n\x04\x04\0\x02\x01\x12\x03\x0b\x02\x20\"\x14\
    \x20center's\x20neighbors\n\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x0b\
    \x02\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x0b\x0b\x11\n\x0c\n\x05\x04\
    \0\x02\x01\x01\x12\x03\x0b\x12\x1b\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\
    \x0b\x1e\x1f\nE\n\x02\x04\x01\x12\x04\x11\0\x18\x01\x1a9*\nOperatorInfo,\
    \x20stores\x20detail\x20information\x20of\x20an\x20operator\n\n\n\n\x03\
    \x04\x01\x01\x12\x03\x11\x08\x14\n\x13\n\x04\x04\x01\x02\0\x12\x03\x12\
    \x02\x18\"\x06\x20type\n\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03\x12\x02\
    \x0e\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x12\x0f\x13\n\x0c\n\x05\x04\
    \x01\x02\0\x03\x12\x03\x12\x16\x17\n*\n\x04\x04\x01\x02\x01\x12\x03\x13\
    \x02\x16\"\x1d\x20only\x20for\x20Reference\x20Operator\n\n\x0c\n\x05\x04\
    \x01\x02\x01\x05\x12\x03\x13\x02\x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\
    \x03\x13\t\x11\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x13\x14\x15\n*\n\
    \x04\x04\x01\x02\x02\x12\x03\x14\x02\x17\"\x1d\x20only\x20for\x20Referen\
    ce\x20Operator\n\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\x14\x02\x08\n\
    \x0c\n\x05\x04\x01\x02\x02\x01\x12\x03\x14\t\x12\n\x0c\n\x05\x04\x01\x02\
    \x02\x03\x12\x03\x14\x15\x16\n\x1b\n\x04\x04\x01\x02\x03\x12\x03\x15\x02\
    \x1e\"\x0e\x20consts\x20value\n\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03\
    \x15\x02\n\n\x0c\n\x05\x04\x01\x02\x03\x06\x12\x03\x15\x0b\x12\n\x0c\n\
    \x05\x04\x01\x02\x03\x01\x12\x03\x15\x13\x19\n\x0c\n\x05\x04\x01\x02\x03\
    \x03\x12\x03\x15\x1c\x1d\n<\n\x04\x04\x01\x02\x04\x12\x03\x16\x02\x1a\"/\
    \x20connector\x20config,\x20only\x20for\x20Connector\x20Operator\n\n\x0c\
    \n\x05\x04\x01\x02\x04\x06\x12\x03\x16\x02\x0b\n\x0c\n\x05\x04\x01\x02\
    \x04\x01\x12\x03\x16\x0c\x15\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03\x16\
    \x18\x19\n\x20\n\x04\x04\x01\x02\x05\x12\x03\x17\x02\x20\"\x13\x20host\
    \x20addr\x20configs\n\n\x0c\n\x05\x04\x01\x02\x05\x06\x12\x03\x17\x02\
    \x11\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03\x17\x12\x1b\n\x0c\n\x05\x04\
    \x01\x02\x05\x03\x12\x03\x17\x1e\x1f\n\x20\n\x02\x04\x02\x12\x04\x1d\0\
    \x20\x01\x1a\x14*\nConstant\x20operator\n\n\n\n\x03\x04\x02\x01\x12\x03\
    \x1d\x08\x0f\nE\n\x04\x04\x02\x02\0\x12\x03\x1e\x02\x12\"8\x20value\x20o\
    f\x20constant,\x20format:\x20[<flag\x20byte>,\x20<data\x20bytes>]\n\n\
    \x0c\n\x05\x04\x02\x02\0\x05\x12\x03\x1e\x02\x07\n\x0c\n\x05\x04\x02\x02\
    \0\x01\x12\x03\x1e\x08\r\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x1e\x10\
    \x11\n\x16\n\x04\x04\x02\x02\x01\x12\x03\x1f\x02\x15\"\t\x20node\x20id\n\
    \n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03\x1f\x02\x08\n\x0c\n\x05\x04\x02\
    \x02\x01\x01\x12\x03\x1f\t\x10\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\
    \x1f\x13\x14\n\n\n\x02\x04\x03\x12\x04#\0'\x01\n\n\n\x03\x04\x03\x01\x12\
    \x03#\x08\x11\n\x0b\n\x04\x04\x03\x02\0\x12\x03$\x02\x1d\n\x0c\n\x05\x04\
    \x03\x02\0\x06\x12\x03$\x02\x13\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03$\
    \x14\x18\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03$\x1b\x1c\n\x0b\n\x04\x04\
    \x03\x02\x01\x12\x03%\x02&\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\x03%\x02\
    \x11\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03%\x12!\n\x0c\n\x05\x04\x03\
    \x02\x01\x03\x12\x03%$%\n\x0b\n\x04\x04\x03\x02\x02\x12\x03&\x02\x16\n\
    \x0c\n\x05\x04\x03\x02\x02\x06\x12\x03&\x02\t\n\x0c\n\x05\x04\x03\x02\
    \x02\x01\x12\x03&\n\x11\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03&\x14\x15\
    \n\n\n\x02\x05\0\x12\x04)\0,\x01\n\n\n\x03\x05\0\x01\x12\x03)\x05\x16\n\
    \x0b\n\x04\x05\0\x02\0\x12\x03*\x02\x0c\n\x0c\n\x05\x05\0\x02\0\x01\x12\
    \x03*\x02\x07\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03*\n\x0b\n\x0b\n\x04\x05\
    \0\x02\x01\x12\x03+\x02\t\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03+\x02\x04\
    \n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03+\x07\x08\n\n\n\x02\x04\x04\x12\
    \x04.\00\x01\n\n\n\x03\x04\x04\x01\x12\x03.\x08\x17\n\x0b\n\x04\x04\x04\
    \x02\0\x12\x03/\x02\x11\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03/\x02\x08\n\
    \x0c\n\x05\x04\x04\x02\0\x01\x12\x03/\t\x0c\n\x0c\n\x05\x04\x04\x02\0\
    \x03\x12\x03/\x0f\x10\n\n\n\x02\x04\x05\x12\x042\05\x01\n\n\n\x03\x04\
    \x05\x01\x12\x032\x08\x0f\n\x0b\n\x04\x04\x05\x02\0\x12\x033\x02!\n\x0c\
    \n\x05\x04\x05\x02\0\x06\x12\x033\x02\x14\n\x0c\n\x05\x04\x05\x02\0\x01\
    \x12\x033\x15\x1c\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x033\x1f\x20\n\x0b\n\
    \x04\x04\x05\x02\x01\x12\x034\x02\x1e\n\x0c\n\x05\x04\x05\x02\x01\x06\
    \x12\x034\x02\x0e\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x034\x0f\x19\n\x0c\
    \n\x05\x04\x05\x02\x01\x03\x12\x034\x1c\x1d\n\n\n\x02\x04\x06\x12\x047\0\
    9\x01\n\n\n\x03\x04\x06\x01\x12\x037\x08\x14\n\n\n\x02\x04\x07\x12\x04;\
    \0>\x01\n\n\n\x03\x04\x07\x01\x12\x03;\x08\x1a\n\x0b\n\x04\x04\x07\x02\0\
    \x12\x03<\x02\x16\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03<\x02\x08\n\x0c\n\
    \x05\x04\x07\x02\0\x01\x12\x03<\t\x11\n\x0c\n\x05\x04\x07\x02\0\x03\x12\
    \x03<\x14\x15\n\x0b\n\x04\x04\x07\x02\x01\x12\x03=\x02\x18\n\x0c\n\x05\
    \x04\x07\x02\x01\x05\x12\x03=\x02\x08\n\x0c\n\x05\x04\x07\x02\x01\x01\
    \x12\x03=\t\x13\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03=\x16\x17\n\x1c\n\
    \x02\x05\x01\x12\x04C\0[\x01\x1a\x10*\nOperator\x20Type\n\n\n\n\x03\x05\
    \x01\x01\x12\x03C\x05\x11\n\x0b\n\x04\x05\x01\x02\0\x12\x03D\x02\x10\n\
    \x0c\n\x05\x05\x01\x02\0\x01\x12\x03D\x02\x0b\n\x0c\n\x05\x05\x01\x02\0\
    \x02\x12\x03D\x0e\x0f\n\x0b\n\x04\x05\x01\x02\x01\x12\x03E\x02\n\n\x0c\n\
    \x05\x05\x01\x02\x01\x01\x12\x03E\x02\x05\n\x0c\n\x05\x05\x01\x02\x01\
    \x02\x12\x03E\x08\t\n\x0b\n\x04\x05\x01\x02\x02\x12\x03F\x02\n\n\x0c\n\
    \x05\x05\x01\x02\x02\x01\x12\x03F\x02\x05\n\x0c\n\x05\x05\x01\x02\x02\
    \x02\x12\x03F\x08\t\n\x0b\n\x04\x05\x01\x02\x03\x12\x03G\x02\x0c\n\x0c\n\
    \x05\x05\x01\x02\x03\x01\x12\x03G\x02\x07\n\x0c\n\x05\x05\x01\x02\x03\
    \x02\x12\x03G\n\x0b\n\x0b\n\x04\x05\x01\x02\x04\x12\x03H\x02\x0e\n\x0c\n\
    \x05\x05\x01\x02\x04\x01\x12\x03H\x02\t\n\x0c\n\x05\x05\x01\x02\x04\x02\
    \x12\x03H\x0c\r\n\x0b\n\x04\x05\x01\x02\x05\x12\x03I\x02\x0c\n\x0c\n\x05\
    \x05\x01\x02\x05\x01\x12\x03I\x02\x07\n\x0c\n\x05\x05\x01\x02\x05\x02\
    \x12\x03I\n\x0b\n\x0b\n\x04\x05\x01\x02\x06\x12\x03J\x02\n\n\x0c\n\x05\
    \x05\x01\x02\x06\x01\x12\x03J\x02\x05\n\x0c\n\x05\x05\x01\x02\x06\x02\
    \x12\x03J\x08\t\n\x0b\n\x04\x05\x01\x02\x07\x12\x03K\x02\x0c\n\x0c\n\x05\
    \x05\x01\x02\x07\x01\x12\x03K\x02\x07\n\x0c\n\x05\x05\x01\x02\x07\x02\
    \x12\x03K\n\x0b\n\x0b\n\x04\x05\x01\x02\x08\x12\x03L\x02\x0e\n\x0c\n\x05\
    \x05\x01\x02\x08\x01\x12\x03L\x02\t\n\x0c\n\x05\x05\x01\x02\x08\x02\x12\
    \x03L\x0c\r\n\x0b\n\x04\x05\x01\x02\t\x12\x03M\x02\n\n\x0c\n\x05\x05\x01\
    \x02\t\x01\x12\x03M\x02\x05\n\x0c\n\x05\x05\x01\x02\t\x02\x12\x03M\x08\t\
    \n\x0b\n\x04\x05\x01\x02\n\x12\x03N\x02\r\n\x0c\n\x05\x05\x01\x02\n\x01\
    \x12\x03N\x02\x07\n\x0c\n\x05\x05\x01\x02\n\x02\x12\x03N\n\x0c\n\x0b\n\
    \x04\x05\x01\x02\x0b\x12\x03O\x02\x0b\n\x0c\n\x05\x05\x01\x02\x0b\x01\
    \x12\x03O\x02\x05\n\x0c\n\x05\x05\x01\x02\x0b\x02\x12\x03O\x08\n\n\x0b\n\
    \x04\x05\x01\x02\x0c\x12\x03P\x02\r\n\x0c\n\x05\x05\x01\x02\x0c\x01\x12\
    \x03P\x02\x07\n\x0c\n\x05\x05\x01\x02\x0c\x02\x12\x03P\n\x0c\n\x0b\n\x04\
    \x05\x01\x02\r\x12\x03Q\x02\x0b\n\x0c\n\x05\x05\x01\x02\r\x01\x12\x03Q\
    \x02\x05\n\x0c\n\x05\x05\x01\x02\r\x02\x12\x03Q\x08\n\n\x0b\n\x04\x05\
    \x01\x02\x0e\x12\x03R\x02\x0b\n\x0c\n\x05\x05\x01\x02\x0e\x01\x12\x03R\
    \x02\x05\n\x0c\n\x05\x05\x01\x02\x0e\x02\x12\x03R\x08\n\n\x0b\n\x04\x05\
    \x01\x02\x0f\x12\x03S\x02\x0b\n\x0c\n\x05\x05\x01\x02\x0f\x01\x12\x03S\
    \x02\x05\n\x0c\n\x05\x05\x01\x02\x0f\x02\x12\x03S\x08\n\n\x0b\n\x04\x05\
    \x01\x02\x10\x12\x03T\x02\n\n\x0c\n\x05\x05\x01\x02\x10\x01\x12\x03T\x02\
    \x04\n\x0c\n\x05\x05\x01\x02\x10\x02\x12\x03T\x07\t\n\x0b\n\x04\x05\x01\
    \x02\x11\x12\x03U\x02\x0b\n\x0c\n\x05\x05\x01\x02\x11\x01\x12\x03U\x02\
    \x05\n\x0c\n\x05\x05\x01\x02\x11\x02\x12\x03U\x08\n\n\x0b\n\x04\x05\x01\
    \x02\x12\x12\x03V\x02\n\n\x0c\n\x05\x05\x01\x02\x12\x01\x12\x03V\x02\x04\
    \n\x0c\n\x05\x05\x01\x02\x12\x02\x12\x03V\x07\t\n\x0b\n\x04\x05\x01\x02\
    \x13\x12\x03W\x02\n\n\x0c\n\x05\x05\x01\x02\x13\x01\x12\x03W\x02\x04\n\
    \x0c\n\x05\x05\x01\x02\x13\x02\x12\x03W\x07\t\n\x0b\n\x04\x05\x01\x02\
    \x14\x12\x03X\x02\x0b\n\x0c\n\x05\x05\x01\x02\x14\x01\x12\x03X\x02\x05\n\
    \x0c\n\x05\x05\x01\x02\x14\x02\x12\x03X\x08\n\n\x0b\n\x04\x05\x01\x02\
    \x15\x12\x03Y\x02\x0b\n\x0c\n\x05\x05\x01\x02\x15\x01\x12\x03Y\x02\x05\n\
    \x0c\n\x05\x05\x01\x02\x15\x02\x12\x03Y\x08\n\n\x0b\n\x04\x05\x01\x02\
    \x16\x12\x03Z\x02\x11\n\x0c\n\x05\x05\x01\x02\x16\x01\x12\x03Z\x02\x0b\n\
    \x0c\n\x05\x05\x01\x02\x16\x02\x12\x03Z\x0e\x10\nN\n\x02\x05\x02\x12\x04\
    `\0e\x01\x1aB*\nStream\x20Graph\x20Status.\x20It\x20shows\x20which\x20st\
    atus\x20a\x20stream\x20job\x20is\x20now.\n\n\n\n\x03\x05\x02\x01\x12\x03\
    `\x05\x13\n\x0b\n\x04\x05\x02\x02\0\x12\x03a\x02\x12\n\x0c\n\x05\x05\x02\
    \x02\0\x01\x12\x03a\x02\r\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03a\x10\x11\
    \n\x0b\n\x04\x05\x02\x02\x01\x12\x03b\x02\x0e\n\x0c\n\x05\x05\x02\x02\
    \x01\x01\x12\x03b\x02\t\n\x0c\n\x05\x05\x02\x02\x01\x02\x12\x03b\x0c\r\n\
    \x0b\n\x04\x05\x02\x02\x02\x12\x03c\x02\x0e\n\x0c\n\x05\x05\x02\x02\x02\
    \x01\x12\x03c\x02\t\n\x0c\n\x05\x05\x02\x02\x02\x02\x12\x03c\x0c\r\n\x0b\
    \n\x04\x05\x02\x02\x03\x12\x03d\x02\r\n\x0c\n\x05\x05\x02\x02\x03\x01\
    \x12\x03d\x02\x08\n\x0c\n\x05\x05\x02\x02\x03\x02\x12\x03d\x0b\x0c\n\n\n\
    \x02\x04\x08\x12\x04g\0l\x01\n\n\n\x03\x04\x08\x01\x12\x03g\x08\x10\nR\n\
    \x04\x04\x08\x02\0\x12\x03h\x02\x1a\"E\x20job\x20id,\x20for\x20now\x20it\
    \x20is\x20which\x20table\x20the\x20stream\x20graph\x20output\x20will\x20\
    sink\n\n\x0c\n\x05\x04\x08\x02\0\x06\x12\x03h\x02\x0e\n\x0c\n\x05\x04\
    \x08\x02\0\x01\x12\x03h\x0f\x15\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03h\
    \x18\x19\n\x1e\n\x04\x04\x08\x02\x01\x12\x03i\x02(\"\x11\x20graph\x20str\
    ucture\n\n\x0c\n\x05\x04\x08\x02\x01\x04\x12\x03i\x02\n\n\x0c\n\x05\x04\
    \x08\x02\x01\x06\x12\x03i\x0b\x1e\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\
    \x03i\x1f#\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03i&'\n\x1f\n\x04\x04\
    \x08\x02\x02\x12\x03j\x02-\"\x12\x20details\x20of\x20nodes\n\n\x0c\n\x05\
    \x04\x08\x02\x02\x06\x12\x03j\x02\"\n\x0c\n\x05\x04\x08\x02\x02\x01\x12\
    \x03j#(\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03j+,\n\x1e\n\x04\x04\x08\
    \x02\x03\x12\x03k\x02\x1c\"\x11\x20dataflow\x20config\n\n\x0c\n\x05\x04\
    \x08\x02\x03\x06\x12\x03k\x02\x10\n\x0c\n\x05\x04\x08\x02\x03\x01\x12\
    \x03k\x11\x17\n\x0c\n\x05\x04\x08\x02\x03\x03\x12\x03k\x1a\x1b\n\n\n\x02\
    \x04\t\x12\x04n\0p\x01\n\n\n\x03\x04\t\x01\x12\x03n\x08\x16\n\x1c\n\x04\
    \x04\t\x02\0\x12\x03o\x02\x1a\"\x0f\x20window\x20config\n\n\x0c\n\x05\
    \x04\t\x02\0\x06\x12\x03o\x02\x0e\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03o\
    \x0f\x15\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03o\x18\x19\n\n\n\x02\x04\n\
    \x12\x04r\0v\x01\n\n\n\x03\x04\n\x01\x12\x03r\x08\x14\n\x0b\n\x04\x04\n\
    \x02\0\x12\x03s\x02\x16\n\x0c\n\x05\x04\n\x02\0\x06\x12\x03s\x02\x0c\n\
    \x0c\n\x05\x04\n\x02\0\x01\x12\x03s\r\x11\n\x0c\n\x05\x04\n\x02\0\x03\
    \x12\x03s\x14\x15\n\x0b\n\x04\x04\n\x02\x01\x12\x03t\x02\x12\n\x0c\n\x05\
    \x04\n\x02\x01\x05\x12\x03t\x02\x08\n\x0c\n\x05\x04\n\x02\x01\x01\x12\
    \x03t\t\r\n\x0c\n\x05\x04\n\x02\x01\x03\x12\x03t\x10\x11\n\x0b\n\x04\x04\
    \n\x02\x02\x12\x03u\x02\x14\n\x0c\n\x05\x04\n\x02\x02\x05\x12\x03u\x02\
    \x08\n\x0c\n\x05\x04\n\x02\x02\x01\x12\x03u\t\x0f\n\x0c\n\x05\x04\n\x02\
    \x02\x03\x12\x03u\x12\x13\n\n\n\x02\x05\x03\x12\x04x\0|\x01\n\n\n\x03\
    \x05\x03\x01\x12\x03x\x05\x0f\n\x0b\n\x04\x05\x03\x02\0\x12\x03y\x02\x0c\
    \n\x0c\n\x05\x05\x03\x02\0\x01\x12\x03y\x02\x07\n\x0c\n\x05\x05\x03\x02\
    \0\x02\x12\x03y\n\x0b\n\x0b\n\x04\x05\x03\x02\x01\x12\x03z\x02\x0e\n\x0c\
    \n\x05\x05\x03\x02\x01\x01\x12\x03z\x02\t\n\x0c\n\x05\x05\x03\x02\x01\
    \x02\x12\x03z\x0c\r\n\x0b\n\x04\x05\x03\x02\x02\x12\x03{\x02\x0e\n\x0c\n\
    \x05\x05\x03\x02\x02\x01\x12\x03{\x02\t\n\x0c\n\x05\x05\x03\x02\x02\x02\
    \x12\x03{\x0c\rb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
