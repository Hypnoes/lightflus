// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `tableflow.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct TableQuery {
    // message fields
    pub tableId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TableQuery {
    fn default() -> &'a TableQuery {
        <TableQuery as ::protobuf::Message>::default_instance()
    }
}

impl TableQuery {
    pub fn new() -> TableQuery {
        ::std::default::Default::default()
    }

    // string tableId = 1;


    pub fn get_tableId(&self) -> &str {
        &self.tableId
    }
    pub fn clear_tableId(&mut self) {
        self.tableId.clear();
    }

    // Param is passed by value, moved
    pub fn set_tableId(&mut self, v: ::std::string::String) {
        self.tableId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tableId(&mut self) -> &mut ::std::string::String {
        &mut self.tableId
    }

    // Take field
    pub fn take_tableId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tableId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TableQuery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tableId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tableId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tableId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.tableId.is_empty() {
            os.write_string(1, &self.tableId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TableQuery {
        TableQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tableId",
                |m: &TableQuery| { &m.tableId },
                |m: &mut TableQuery| { &mut m.tableId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TableQuery>(
                "TableQuery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TableQuery {
        static instance: ::protobuf::rt::LazyV2<TableQuery> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TableQuery::new)
    }
}

impl ::protobuf::Clear for TableQuery {
    fn clear(&mut self) {
        self.tableId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TableQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TableQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Table {
    // message fields
    pub id: ::std::string::String,
    pub headers: ::protobuf::RepeatedField<Table_HeaderMeta>,
    pub code: ::std::string::String,
    pub workspaceId: ::std::string::String,
    pub name: ::std::string::String,
    pub creatAt: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub modifyAt: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Table {
    fn default() -> &'a Table {
        <Table as ::protobuf::Message>::default_instance()
    }
}

impl Table {
    pub fn new() -> Table {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // repeated .tableflow.Table.HeaderMeta headers = 2;


    pub fn get_headers(&self) -> &[Table_HeaderMeta] {
        &self.headers
    }
    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::protobuf::RepeatedField<Table_HeaderMeta>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::protobuf::RepeatedField<Table_HeaderMeta> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::protobuf::RepeatedField<Table_HeaderMeta> {
        ::std::mem::replace(&mut self.headers, ::protobuf::RepeatedField::new())
    }

    // string code = 3;


    pub fn get_code(&self) -> &str {
        &self.code
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.code, ::std::string::String::new())
    }

    // string workspaceId = 4;


    pub fn get_workspaceId(&self) -> &str {
        &self.workspaceId
    }
    pub fn clear_workspaceId(&mut self) {
        self.workspaceId.clear();
    }

    // Param is passed by value, moved
    pub fn set_workspaceId(&mut self, v: ::std::string::String) {
        self.workspaceId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workspaceId(&mut self) -> &mut ::std::string::String {
        &mut self.workspaceId
    }

    // Take field
    pub fn take_workspaceId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.workspaceId, ::std::string::String::new())
    }

    // string name = 5;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp creatAt = 6;


    pub fn get_creatAt(&self) -> &::protobuf::well_known_types::Timestamp {
        self.creatAt.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_creatAt(&mut self) {
        self.creatAt.clear();
    }

    pub fn has_creatAt(&self) -> bool {
        self.creatAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creatAt(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.creatAt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creatAt(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.creatAt.is_none() {
            self.creatAt.set_default();
        }
        self.creatAt.as_mut().unwrap()
    }

    // Take field
    pub fn take_creatAt(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.creatAt.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp modifyAt = 7;


    pub fn get_modifyAt(&self) -> &::protobuf::well_known_types::Timestamp {
        self.modifyAt.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_modifyAt(&mut self) {
        self.modifyAt.clear();
    }

    pub fn has_modifyAt(&self) -> bool {
        self.modifyAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modifyAt(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.modifyAt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modifyAt(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.modifyAt.is_none() {
            self.modifyAt.set_default();
        }
        self.modifyAt.as_mut().unwrap()
    }

    // Take field
    pub fn take_modifyAt(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.modifyAt.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for Table {
    fn is_initialized(&self) -> bool {
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.creatAt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modifyAt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.headers)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.code)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.workspaceId)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creatAt)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modifyAt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.code);
        }
        if !self.workspaceId.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.workspaceId);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.name);
        }
        if let Some(ref v) = self.creatAt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modifyAt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        for v in &self.headers {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.code.is_empty() {
            os.write_string(3, &self.code)?;
        }
        if !self.workspaceId.is_empty() {
            os.write_string(4, &self.workspaceId)?;
        }
        if !self.name.is_empty() {
            os.write_string(5, &self.name)?;
        }
        if let Some(ref v) = self.creatAt.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modifyAt.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Table {
        Table::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Table| { &m.id },
                |m: &mut Table| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Table_HeaderMeta>>(
                "headers",
                |m: &Table| { &m.headers },
                |m: &mut Table| { &mut m.headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "code",
                |m: &Table| { &m.code },
                |m: &mut Table| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workspaceId",
                |m: &Table| { &m.workspaceId },
                |m: &mut Table| { &mut m.workspaceId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Table| { &m.name },
                |m: &mut Table| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "creatAt",
                |m: &Table| { &m.creatAt },
                |m: &mut Table| { &mut m.creatAt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "modifyAt",
                |m: &Table| { &m.modifyAt },
                |m: &mut Table| { &mut m.modifyAt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Table>(
                "Table",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Table {
        static instance: ::protobuf::rt::LazyV2<Table> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Table::new)
    }
}

impl ::protobuf::Clear for Table {
    fn clear(&mut self) {
        self.id.clear();
        self.headers.clear();
        self.code.clear();
        self.workspaceId.clear();
        self.name.clear();
        self.creatAt.clear();
        self.modifyAt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Table {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Table {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Table_HeaderMeta {
    // message fields
    pub id: ::std::string::String,
    pub field_type: Table_HeaderType,
    pub index: u32,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Table_HeaderMeta {
    fn default() -> &'a Table_HeaderMeta {
        <Table_HeaderMeta as ::protobuf::Message>::default_instance()
    }
}

impl Table_HeaderMeta {
    pub fn new() -> Table_HeaderMeta {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .tableflow.Table.HeaderType type = 2;


    pub fn get_field_type(&self) -> Table_HeaderType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Table_HeaderType::Text;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Table_HeaderType) {
        self.field_type = v;
    }

    // uint32 index = 3;


    pub fn get_index(&self) -> u32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = v;
    }

    // string name = 4;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Table_HeaderMeta {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.index = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.field_type != Table_HeaderType::Text {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(3, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.field_type != Table_HeaderType::Text {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.index != 0 {
            os.write_uint32(3, self.index)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Table_HeaderMeta {
        Table_HeaderMeta::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Table_HeaderMeta| { &m.id },
                |m: &mut Table_HeaderMeta| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Table_HeaderType>>(
                "type",
                |m: &Table_HeaderMeta| { &m.field_type },
                |m: &mut Table_HeaderMeta| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "index",
                |m: &Table_HeaderMeta| { &m.index },
                |m: &mut Table_HeaderMeta| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Table_HeaderMeta| { &m.name },
                |m: &mut Table_HeaderMeta| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Table_HeaderMeta>(
                "Table.HeaderMeta",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Table_HeaderMeta {
        static instance: ::protobuf::rt::LazyV2<Table_HeaderMeta> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Table_HeaderMeta::new)
    }
}

impl ::protobuf::Clear for Table_HeaderMeta {
    fn clear(&mut self) {
        self.id.clear();
        self.field_type = Table_HeaderType::Text;
        self.index = 0;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Table_HeaderMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Table_HeaderMeta {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Table_HeaderType {
    Text = 0,
    Integer = 1,
    Number = 2,
    Date = 3,
    Time = 4,
    Percent = 5,
}

impl ::protobuf::ProtobufEnum for Table_HeaderType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Table_HeaderType> {
        match value {
            0 => ::std::option::Option::Some(Table_HeaderType::Text),
            1 => ::std::option::Option::Some(Table_HeaderType::Integer),
            2 => ::std::option::Option::Some(Table_HeaderType::Number),
            3 => ::std::option::Option::Some(Table_HeaderType::Date),
            4 => ::std::option::Option::Some(Table_HeaderType::Time),
            5 => ::std::option::Option::Some(Table_HeaderType::Percent),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Table_HeaderType] = &[
            Table_HeaderType::Text,
            Table_HeaderType::Integer,
            Table_HeaderType::Number,
            Table_HeaderType::Date,
            Table_HeaderType::Time,
            Table_HeaderType::Percent,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Table_HeaderType>("Table.HeaderType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Table_HeaderType {
}

impl ::std::default::Default for Table_HeaderType {
    fn default() -> Self {
        Table_HeaderType::Text
    }
}

impl ::protobuf::reflect::ProtobufValue for Table_HeaderType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateMetadataRequest {
    // message fields
    pub id: ::std::string::String,
    pub updated: ::protobuf::SingularPtrField<Table>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateMetadataRequest {
    fn default() -> &'a UpdateMetadataRequest {
        <UpdateMetadataRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateMetadataRequest {
    pub fn new() -> UpdateMetadataRequest {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .tableflow.Table updated = 2;


    pub fn get_updated(&self) -> &Table {
        self.updated.as_ref().unwrap_or_else(|| <Table as ::protobuf::Message>::default_instance())
    }
    pub fn clear_updated(&mut self) {
        self.updated.clear();
    }

    pub fn has_updated(&self) -> bool {
        self.updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated(&mut self, v: Table) {
        self.updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated(&mut self) -> &mut Table {
        if self.updated.is_none() {
            self.updated.set_default();
        }
        self.updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated(&mut self) -> Table {
        self.updated.take().unwrap_or_else(|| Table::new())
    }
}

impl ::protobuf::Message for UpdateMetadataRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.updated {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.updated.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateMetadataRequest {
        UpdateMetadataRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &UpdateMetadataRequest| { &m.id },
                |m: &mut UpdateMetadataRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Table>>(
                "updated",
                |m: &UpdateMetadataRequest| { &m.updated },
                |m: &mut UpdateMetadataRequest| { &mut m.updated },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateMetadataRequest>(
                "UpdateMetadataRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateMetadataRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateMetadataRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateMetadataRequest::new)
    }
}

impl ::protobuf::Clear for UpdateMetadataRequest {
    fn clear(&mut self) {
        self.id.clear();
        self.updated.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateMetadataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateMetadataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryRequest {
    // message fields
    pub tableId: ::std::string::String,
    pub headerId: ::std::string::String,
    pub options: ::protobuf::SingularPtrField<Options>,
    pub query: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryRequest {
    fn default() -> &'a QueryRequest {
        <QueryRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryRequest {
    pub fn new() -> QueryRequest {
        ::std::default::Default::default()
    }

    // string tableId = 1;


    pub fn get_tableId(&self) -> &str {
        &self.tableId
    }
    pub fn clear_tableId(&mut self) {
        self.tableId.clear();
    }

    // Param is passed by value, moved
    pub fn set_tableId(&mut self, v: ::std::string::String) {
        self.tableId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tableId(&mut self) -> &mut ::std::string::String {
        &mut self.tableId
    }

    // Take field
    pub fn take_tableId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tableId, ::std::string::String::new())
    }

    // string headerId = 2;


    pub fn get_headerId(&self) -> &str {
        &self.headerId
    }
    pub fn clear_headerId(&mut self) {
        self.headerId.clear();
    }

    // Param is passed by value, moved
    pub fn set_headerId(&mut self, v: ::std::string::String) {
        self.headerId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headerId(&mut self) -> &mut ::std::string::String {
        &mut self.headerId
    }

    // Take field
    pub fn take_headerId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.headerId, ::std::string::String::new())
    }

    // .tableflow.Options options = 3;


    pub fn get_options(&self) -> &Options {
        self.options.as_ref().unwrap_or_else(|| <Options as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: Options) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut Options {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> Options {
        self.options.take().unwrap_or_else(|| Options::new())
    }

    // .google.protobuf.Struct query = 4;


    pub fn get_query(&self) -> &::protobuf::well_known_types::Struct {
        self.query.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.query.is_none() {
            self.query.set_default();
        }
        self.query.as_mut().unwrap()
    }

    // Take field
    pub fn take_query(&mut self) -> ::protobuf::well_known_types::Struct {
        self.query.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }
}

impl ::protobuf::Message for QueryRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.query {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tableId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.headerId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tableId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tableId);
        }
        if !self.headerId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.headerId);
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.tableId.is_empty() {
            os.write_string(1, &self.tableId)?;
        }
        if !self.headerId.is_empty() {
            os.write_string(2, &self.headerId)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.query.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRequest {
        QueryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tableId",
                |m: &QueryRequest| { &m.tableId },
                |m: &mut QueryRequest| { &mut m.tableId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "headerId",
                |m: &QueryRequest| { &m.headerId },
                |m: &mut QueryRequest| { &mut m.headerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Options>>(
                "options",
                |m: &QueryRequest| { &m.options },
                |m: &mut QueryRequest| { &mut m.options },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "query",
                |m: &QueryRequest| { &m.query },
                |m: &mut QueryRequest| { &mut m.query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryRequest>(
                "QueryRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryRequest {
        static instance: ::protobuf::rt::LazyV2<QueryRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryRequest::new)
    }
}

impl ::protobuf::Clear for QueryRequest {
    fn clear(&mut self) {
        self.tableId.clear();
        self.headerId.clear();
        self.options.clear();
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Options {
    // message fields
    pub page: u32,
    pub limit: u32,
    pub sort: Options_Sort,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Options {
    fn default() -> &'a Options {
        <Options as ::protobuf::Message>::default_instance()
    }
}

impl Options {
    pub fn new() -> Options {
        ::std::default::Default::default()
    }

    // uint32 page = 1;


    pub fn get_page(&self) -> u32 {
        self.page
    }
    pub fn clear_page(&mut self) {
        self.page = 0;
    }

    // Param is passed by value, moved
    pub fn set_page(&mut self, v: u32) {
        self.page = v;
    }

    // uint32 limit = 2;


    pub fn get_limit(&self) -> u32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u32) {
        self.limit = v;
    }

    // .tableflow.Options.Sort sort = 3;


    pub fn get_sort(&self) -> Options_Sort {
        self.sort
    }
    pub fn clear_sort(&mut self) {
        self.sort = Options_Sort::Asc;
    }

    // Param is passed by value, moved
    pub fn set_sort(&mut self, v: Options_Sort) {
        self.sort = v;
    }
}

impl ::protobuf::Message for Options {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.limit = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sort, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.page != 0 {
            my_size += ::protobuf::rt::value_size(1, self.page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sort != Options_Sort::Asc {
            my_size += ::protobuf::rt::enum_size(3, self.sort);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.page != 0 {
            os.write_uint32(1, self.page)?;
        }
        if self.limit != 0 {
            os.write_uint32(2, self.limit)?;
        }
        if self.sort != Options_Sort::Asc {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.sort))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Options {
        Options::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page",
                |m: &Options| { &m.page },
                |m: &mut Options| { &mut m.page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "limit",
                |m: &Options| { &m.limit },
                |m: &mut Options| { &mut m.limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Options_Sort>>(
                "sort",
                |m: &Options| { &m.sort },
                |m: &mut Options| { &mut m.sort },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Options>(
                "Options",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Options {
        static instance: ::protobuf::rt::LazyV2<Options> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Options::new)
    }
}

impl ::protobuf::Clear for Options {
    fn clear(&mut self) {
        self.page = 0;
        self.limit = 0;
        self.sort = Options_Sort::Asc;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Options {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Options {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Options_Sort {
    Asc = 0,
    Desc = 1,
}

impl ::protobuf::ProtobufEnum for Options_Sort {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Options_Sort> {
        match value {
            0 => ::std::option::Option::Some(Options_Sort::Asc),
            1 => ::std::option::Option::Some(Options_Sort::Desc),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Options_Sort] = &[
            Options_Sort::Asc,
            Options_Sort::Desc,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Options_Sort>("Options.Sort", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Options_Sort {
}

impl ::std::default::Default for Options_Sort {
    fn default() -> Self {
        Options_Sort::Asc
    }
}

impl ::protobuf::reflect::ProtobufValue for Options_Sort {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryResponse {
    // message fields
    pub resultSet: ::protobuf::RepeatedField<Entry>,
    pub status: Status,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryResponse {
    fn default() -> &'a QueryResponse {
        <QueryResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryResponse {
    pub fn new() -> QueryResponse {
        ::std::default::Default::default()
    }

    // repeated .tableflow.Entry resultSet = 1;


    pub fn get_resultSet(&self) -> &[Entry] {
        &self.resultSet
    }
    pub fn clear_resultSet(&mut self) {
        self.resultSet.clear();
    }

    // Param is passed by value, moved
    pub fn set_resultSet(&mut self, v: ::protobuf::RepeatedField<Entry>) {
        self.resultSet = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resultSet(&mut self) -> &mut ::protobuf::RepeatedField<Entry> {
        &mut self.resultSet
    }

    // Take field
    pub fn take_resultSet(&mut self) -> ::protobuf::RepeatedField<Entry> {
        ::std::mem::replace(&mut self.resultSet, ::protobuf::RepeatedField::new())
    }

    // .tableflow.Status status = 2;


    pub fn get_status(&self) -> Status {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = Status::Success;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = v;
    }
}

impl ::protobuf::Message for QueryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.resultSet {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resultSet)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.resultSet {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.status != Status::Success {
            my_size += ::protobuf::rt::enum_size(2, self.status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.resultSet {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.status != Status::Success {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryResponse {
        QueryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Entry>>(
                "resultSet",
                |m: &QueryResponse| { &m.resultSet },
                |m: &mut QueryResponse| { &mut m.resultSet },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                "status",
                |m: &QueryResponse| { &m.status },
                |m: &mut QueryResponse| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryResponse>(
                "QueryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryResponse {
        static instance: ::protobuf::rt::LazyV2<QueryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryResponse::new)
    }
}

impl ::protobuf::Clear for QueryResponse {
    fn clear(&mut self) {
        self.resultSet.clear();
        self.status = Status::Success;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Entry {
    // message fields
    pub rowIdx: u64,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Entry {
    fn default() -> &'a Entry {
        <Entry as ::protobuf::Message>::default_instance()
    }
}

impl Entry {
    pub fn new() -> Entry {
        ::std::default::Default::default()
    }

    // uint64 rowIdx = 1;


    pub fn get_rowIdx(&self) -> u64 {
        self.rowIdx
    }
    pub fn clear_rowIdx(&mut self) {
        self.rowIdx = 0;
    }

    // Param is passed by value, moved
    pub fn set_rowIdx(&mut self, v: u64) {
        self.rowIdx = v;
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Entry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rowIdx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.rowIdx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.rowIdx, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.rowIdx != 0 {
            os.write_uint64(1, self.rowIdx)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Entry {
        Entry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "rowIdx",
                |m: &Entry| { &m.rowIdx },
                |m: &mut Entry| { &mut m.rowIdx },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &Entry| { &m.value },
                |m: &mut Entry| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Entry>(
                "Entry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Entry {
        static instance: ::protobuf::rt::LazyV2<Entry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Entry::new)
    }
}

impl ::protobuf::Clear for Entry {
    fn clear(&mut self) {
        self.rowIdx = 0;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRequest {
    // message fields
    pub tableId: ::std::string::String,
    pub headerId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteRequest {
    fn default() -> &'a DeleteRequest {
        <DeleteRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRequest {
    pub fn new() -> DeleteRequest {
        ::std::default::Default::default()
    }

    // string tableId = 1;


    pub fn get_tableId(&self) -> &str {
        &self.tableId
    }
    pub fn clear_tableId(&mut self) {
        self.tableId.clear();
    }

    // Param is passed by value, moved
    pub fn set_tableId(&mut self, v: ::std::string::String) {
        self.tableId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tableId(&mut self) -> &mut ::std::string::String {
        &mut self.tableId
    }

    // Take field
    pub fn take_tableId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tableId, ::std::string::String::new())
    }

    // string headerId = 2;


    pub fn get_headerId(&self) -> &str {
        &self.headerId
    }
    pub fn clear_headerId(&mut self) {
        self.headerId.clear();
    }

    // Param is passed by value, moved
    pub fn set_headerId(&mut self, v: ::std::string::String) {
        self.headerId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headerId(&mut self) -> &mut ::std::string::String {
        &mut self.headerId
    }

    // Take field
    pub fn take_headerId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.headerId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tableId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.headerId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tableId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tableId);
        }
        if !self.headerId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.headerId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.tableId.is_empty() {
            os.write_string(1, &self.tableId)?;
        }
        if !self.headerId.is_empty() {
            os.write_string(2, &self.headerId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteRequest {
        DeleteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tableId",
                |m: &DeleteRequest| { &m.tableId },
                |m: &mut DeleteRequest| { &mut m.tableId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "headerId",
                |m: &DeleteRequest| { &m.headerId },
                |m: &mut DeleteRequest| { &mut m.headerId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteRequest>(
                "DeleteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteRequest::new)
    }
}

impl ::protobuf::Clear for DeleteRequest {
    fn clear(&mut self) {
        self.tableId.clear();
        self.headerId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response {
    // message fields
    pub status: Status,
    pub errMsg: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response {
    fn default() -> &'a Response {
        <Response as ::protobuf::Message>::default_instance()
    }
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }

    // .tableflow.Status status = 1;


    pub fn get_status(&self) -> Status {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = Status::Success;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = v;
    }

    // string errMsg = 2;


    pub fn get_errMsg(&self) -> &str {
        &self.errMsg
    }
    pub fn clear_errMsg(&mut self) {
        self.errMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_errMsg(&mut self, v: ::std::string::String) {
        self.errMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errMsg(&mut self) -> &mut ::std::string::String {
        &mut self.errMsg
    }

    // Take field
    pub fn take_errMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.errMsg, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.errMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != Status::Success {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        if !self.errMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.errMsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != Status::Success {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if !self.errMsg.is_empty() {
            os.write_string(2, &self.errMsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response {
        Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                "status",
                |m: &Response| { &m.status },
                |m: &mut Response| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "errMsg",
                |m: &Response| { &m.errMsg },
                |m: &mut Response| { &mut m.errMsg },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Response>(
                "Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Response {
        static instance: ::protobuf::rt::LazyV2<Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response::new)
    }
}

impl ::protobuf::Clear for Response {
    fn clear(&mut self) {
        self.status = Status::Success;
        self.errMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateRequest {
    // message fields
    pub action: UpdateRequest_Action,
    pub tableId: ::std::string::String,
    pub headerId: ::std::string::String,
    pub entries: ::protobuf::RepeatedField<Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateRequest {
    fn default() -> &'a UpdateRequest {
        <UpdateRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateRequest {
    pub fn new() -> UpdateRequest {
        ::std::default::Default::default()
    }

    // .tableflow.UpdateRequest.Action action = 1;


    pub fn get_action(&self) -> UpdateRequest_Action {
        self.action
    }
    pub fn clear_action(&mut self) {
        self.action = UpdateRequest_Action::UpdateEntry;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: UpdateRequest_Action) {
        self.action = v;
    }

    // string tableId = 2;


    pub fn get_tableId(&self) -> &str {
        &self.tableId
    }
    pub fn clear_tableId(&mut self) {
        self.tableId.clear();
    }

    // Param is passed by value, moved
    pub fn set_tableId(&mut self, v: ::std::string::String) {
        self.tableId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tableId(&mut self) -> &mut ::std::string::String {
        &mut self.tableId
    }

    // Take field
    pub fn take_tableId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tableId, ::std::string::String::new())
    }

    // string headerId = 3;


    pub fn get_headerId(&self) -> &str {
        &self.headerId
    }
    pub fn clear_headerId(&mut self) {
        self.headerId.clear();
    }

    // Param is passed by value, moved
    pub fn set_headerId(&mut self, v: ::std::string::String) {
        self.headerId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headerId(&mut self) -> &mut ::std::string::String {
        &mut self.headerId
    }

    // Take field
    pub fn take_headerId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.headerId, ::std::string::String::new())
    }

    // repeated .tableflow.Entry entries = 4;


    pub fn get_entries(&self) -> &[Entry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<Entry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<Entry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<Entry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UpdateRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tableId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.headerId)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.action != UpdateRequest_Action::UpdateEntry {
            my_size += ::protobuf::rt::enum_size(1, self.action);
        }
        if !self.tableId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tableId);
        }
        if !self.headerId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.headerId);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.action != UpdateRequest_Action::UpdateEntry {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.action))?;
        }
        if !self.tableId.is_empty() {
            os.write_string(2, &self.tableId)?;
        }
        if !self.headerId.is_empty() {
            os.write_string(3, &self.headerId)?;
        }
        for v in &self.entries {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateRequest {
        UpdateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UpdateRequest_Action>>(
                "action",
                |m: &UpdateRequest| { &m.action },
                |m: &mut UpdateRequest| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tableId",
                |m: &UpdateRequest| { &m.tableId },
                |m: &mut UpdateRequest| { &mut m.tableId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "headerId",
                |m: &UpdateRequest| { &m.headerId },
                |m: &mut UpdateRequest| { &mut m.headerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Entry>>(
                "entries",
                |m: &UpdateRequest| { &m.entries },
                |m: &mut UpdateRequest| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateRequest>(
                "UpdateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateRequest::new)
    }
}

impl ::protobuf::Clear for UpdateRequest {
    fn clear(&mut self) {
        self.action = UpdateRequest_Action::UpdateEntry;
        self.tableId.clear();
        self.headerId.clear();
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UpdateRequest_Action {
    UpdateEntry = 0,
    DeleteEntry = 1,
}

impl ::protobuf::ProtobufEnum for UpdateRequest_Action {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UpdateRequest_Action> {
        match value {
            0 => ::std::option::Option::Some(UpdateRequest_Action::UpdateEntry),
            1 => ::std::option::Option::Some(UpdateRequest_Action::DeleteEntry),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UpdateRequest_Action] = &[
            UpdateRequest_Action::UpdateEntry,
            UpdateRequest_Action::DeleteEntry,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<UpdateRequest_Action>("UpdateRequest.Action", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for UpdateRequest_Action {
}

impl ::std::default::Default for UpdateRequest_Action {
    fn default() -> Self {
        UpdateRequest_Action::UpdateEntry
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateRequest_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateResponse {
    // message fields
    pub status: Status,
    pub errMsg: ::std::string::String,
    pub affectedEntries: u32,
    pub lastRowIdx: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateResponse {
    fn default() -> &'a UpdateResponse {
        <UpdateResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateResponse {
    pub fn new() -> UpdateResponse {
        ::std::default::Default::default()
    }

    // .tableflow.Status status = 1;


    pub fn get_status(&self) -> Status {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = Status::Success;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = v;
    }

    // string errMsg = 2;


    pub fn get_errMsg(&self) -> &str {
        &self.errMsg
    }
    pub fn clear_errMsg(&mut self) {
        self.errMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_errMsg(&mut self, v: ::std::string::String) {
        self.errMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errMsg(&mut self) -> &mut ::std::string::String {
        &mut self.errMsg
    }

    // Take field
    pub fn take_errMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.errMsg, ::std::string::String::new())
    }

    // uint32 affectedEntries = 3;


    pub fn get_affectedEntries(&self) -> u32 {
        self.affectedEntries
    }
    pub fn clear_affectedEntries(&mut self) {
        self.affectedEntries = 0;
    }

    // Param is passed by value, moved
    pub fn set_affectedEntries(&mut self, v: u32) {
        self.affectedEntries = v;
    }

    // uint64 lastRowIdx = 4;


    pub fn get_lastRowIdx(&self) -> u64 {
        self.lastRowIdx
    }
    pub fn clear_lastRowIdx(&mut self) {
        self.lastRowIdx = 0;
    }

    // Param is passed by value, moved
    pub fn set_lastRowIdx(&mut self, v: u64) {
        self.lastRowIdx = v;
    }
}

impl ::protobuf::Message for UpdateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.errMsg)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.affectedEntries = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lastRowIdx = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != Status::Success {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        if !self.errMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.errMsg);
        }
        if self.affectedEntries != 0 {
            my_size += ::protobuf::rt::value_size(3, self.affectedEntries, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lastRowIdx != 0 {
            my_size += ::protobuf::rt::value_size(4, self.lastRowIdx, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != Status::Success {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if !self.errMsg.is_empty() {
            os.write_string(2, &self.errMsg)?;
        }
        if self.affectedEntries != 0 {
            os.write_uint32(3, self.affectedEntries)?;
        }
        if self.lastRowIdx != 0 {
            os.write_uint64(4, self.lastRowIdx)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateResponse {
        UpdateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                "status",
                |m: &UpdateResponse| { &m.status },
                |m: &mut UpdateResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "errMsg",
                |m: &UpdateResponse| { &m.errMsg },
                |m: &mut UpdateResponse| { &mut m.errMsg },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "affectedEntries",
                |m: &UpdateResponse| { &m.affectedEntries },
                |m: &mut UpdateResponse| { &mut m.affectedEntries },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lastRowIdx",
                |m: &UpdateResponse| { &m.lastRowIdx },
                |m: &mut UpdateResponse| { &mut m.lastRowIdx },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateResponse>(
                "UpdateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateResponse::new)
    }
}

impl ::protobuf::Clear for UpdateResponse {
    fn clear(&mut self) {
        self.status = Status::Success;
        self.errMsg.clear();
        self.affectedEntries = 0;
        self.lastRowIdx = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InsertRequest {
    // message fields
    pub tableId: ::std::string::String,
    pub headerId: ::std::string::String,
    pub entries: ::protobuf::RepeatedField<Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InsertRequest {
    fn default() -> &'a InsertRequest {
        <InsertRequest as ::protobuf::Message>::default_instance()
    }
}

impl InsertRequest {
    pub fn new() -> InsertRequest {
        ::std::default::Default::default()
    }

    // string tableId = 1;


    pub fn get_tableId(&self) -> &str {
        &self.tableId
    }
    pub fn clear_tableId(&mut self) {
        self.tableId.clear();
    }

    // Param is passed by value, moved
    pub fn set_tableId(&mut self, v: ::std::string::String) {
        self.tableId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tableId(&mut self) -> &mut ::std::string::String {
        &mut self.tableId
    }

    // Take field
    pub fn take_tableId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tableId, ::std::string::String::new())
    }

    // string headerId = 2;


    pub fn get_headerId(&self) -> &str {
        &self.headerId
    }
    pub fn clear_headerId(&mut self) {
        self.headerId.clear();
    }

    // Param is passed by value, moved
    pub fn set_headerId(&mut self, v: ::std::string::String) {
        self.headerId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headerId(&mut self) -> &mut ::std::string::String {
        &mut self.headerId
    }

    // Take field
    pub fn take_headerId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.headerId, ::std::string::String::new())
    }

    // repeated .tableflow.Entry entries = 3;


    pub fn get_entries(&self) -> &[Entry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<Entry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<Entry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<Entry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for InsertRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tableId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.headerId)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tableId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tableId);
        }
        if !self.headerId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.headerId);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.tableId.is_empty() {
            os.write_string(1, &self.tableId)?;
        }
        if !self.headerId.is_empty() {
            os.write_string(2, &self.headerId)?;
        }
        for v in &self.entries {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InsertRequest {
        InsertRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tableId",
                |m: &InsertRequest| { &m.tableId },
                |m: &mut InsertRequest| { &mut m.tableId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "headerId",
                |m: &InsertRequest| { &m.headerId },
                |m: &mut InsertRequest| { &mut m.headerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Entry>>(
                "entries",
                |m: &InsertRequest| { &m.entries },
                |m: &mut InsertRequest| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InsertRequest>(
                "InsertRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InsertRequest {
        static instance: ::protobuf::rt::LazyV2<InsertRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InsertRequest::new)
    }
}

impl ::protobuf::Clear for InsertRequest {
    fn clear(&mut self) {
        self.tableId.clear();
        self.headerId.clear();
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InsertRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InsertRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InsertResponse {
    // message fields
    pub status: Status,
    pub errMsg: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InsertResponse {
    fn default() -> &'a InsertResponse {
        <InsertResponse as ::protobuf::Message>::default_instance()
    }
}

impl InsertResponse {
    pub fn new() -> InsertResponse {
        ::std::default::Default::default()
    }

    // .tableflow.Status status = 1;


    pub fn get_status(&self) -> Status {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = Status::Success;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = v;
    }

    // string errMsg = 2;


    pub fn get_errMsg(&self) -> &str {
        &self.errMsg
    }
    pub fn clear_errMsg(&mut self) {
        self.errMsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_errMsg(&mut self, v: ::std::string::String) {
        self.errMsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errMsg(&mut self) -> &mut ::std::string::String {
        &mut self.errMsg
    }

    // Take field
    pub fn take_errMsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.errMsg, ::std::string::String::new())
    }
}

impl ::protobuf::Message for InsertResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.errMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != Status::Success {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        if !self.errMsg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.errMsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != Status::Success {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if !self.errMsg.is_empty() {
            os.write_string(2, &self.errMsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InsertResponse {
        InsertResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                "status",
                |m: &InsertResponse| { &m.status },
                |m: &mut InsertResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "errMsg",
                |m: &InsertResponse| { &m.errMsg },
                |m: &mut InsertResponse| { &mut m.errMsg },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InsertResponse>(
                "InsertResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InsertResponse {
        static instance: ::protobuf::rt::LazyV2<InsertResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InsertResponse::new)
    }
}

impl ::protobuf::Clear for InsertResponse {
    fn clear(&mut self) {
        self.status = Status::Success;
        self.errMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InsertResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InsertResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Status {
    Success = 0,
    Failure = 1,
}

impl ::protobuf::ProtobufEnum for Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Status> {
        match value {
            0 => ::std::option::Option::Some(Status::Success),
            1 => ::std::option::Option::Some(Status::Failure),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Status] = &[
            Status::Success,
            Status::Failure,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Status>("Status", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Status {
}

impl ::std::default::Default for Status {
    fn default() -> Self {
        Status::Success
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0ftableflow.proto\x12\ttableflow\x1a\x1cgoogle/protobuf/struct.proto\
    \x1a\x1fgoogle/protobuf/timestamp.proto\"&\n\nTableQuery\x12\x18\n\x07ta\
    bleId\x18\x01\x20\x01(\tR\x07tableId\"\xd1\x03\n\x05Table\x12\x0e\n\x02i\
    d\x18\x01\x20\x01(\tR\x02id\x125\n\x07headers\x18\x02\x20\x03(\x0b2\x1b.\
    tableflow.Table.HeaderMetaR\x07headers\x12\x12\n\x04code\x18\x03\x20\x01\
    (\tR\x04code\x12\x20\n\x0bworkspaceId\x18\x04\x20\x01(\tR\x0bworkspaceId\
    \x12\x12\n\x04name\x18\x05\x20\x01(\tR\x04name\x124\n\x07creatAt\x18\x06\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x07creatAt\x126\n\x08modif\
    yAt\x18\x07\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x08modifyAt\x1a\
    w\n\nHeaderMeta\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12/\n\x04type\
    \x18\x02\x20\x01(\x0e2\x1b.tableflow.Table.HeaderTypeR\x04type\x12\x14\n\
    \x05index\x18\x03\x20\x01(\rR\x05index\x12\x12\n\x04name\x18\x04\x20\x01\
    (\tR\x04name\"P\n\nHeaderType\x12\x08\n\x04Text\x10\0\x12\x0b\n\x07Integ\
    er\x10\x01\x12\n\n\x06Number\x10\x02\x12\x08\n\x04Date\x10\x03\x12\x08\n\
    \x04Time\x10\x04\x12\x0b\n\x07Percent\x10\x05\"S\n\x15UpdateMetadataRequ\
    est\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12*\n\x07updated\x18\x02\
    \x20\x01(\x0b2\x10.tableflow.TableR\x07updated\"\xa1\x01\n\x0cQueryReque\
    st\x12\x18\n\x07tableId\x18\x01\x20\x01(\tR\x07tableId\x12\x1a\n\x08head\
    erId\x18\x02\x20\x01(\tR\x08headerId\x12,\n\x07options\x18\x03\x20\x01(\
    \x0b2\x12.tableflow.OptionsR\x07options\x12-\n\x05query\x18\x04\x20\x01(\
    \x0b2\x17.google.protobuf.StructR\x05query\"{\n\x07Options\x12\x12\n\x04\
    page\x18\x01\x20\x01(\rR\x04page\x12\x14\n\x05limit\x18\x02\x20\x01(\rR\
    \x05limit\x12+\n\x04sort\x18\x03\x20\x01(\x0e2\x17.tableflow.Options.Sor\
    tR\x04sort\"\x19\n\x04Sort\x12\x07\n\x03Asc\x10\0\x12\x08\n\x04Desc\x10\
    \x01\"j\n\rQueryResponse\x12.\n\tresultSet\x18\x01\x20\x03(\x0b2\x10.tab\
    leflow.EntryR\tresultSet\x12)\n\x06status\x18\x02\x20\x01(\x0e2\x11.tabl\
    eflow.StatusR\x06status\"5\n\x05Entry\x12\x16\n\x06rowIdx\x18\x01\x20\
    \x01(\x04R\x06rowIdx\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value\"\
    E\n\rDeleteRequest\x12\x18\n\x07tableId\x18\x01\x20\x01(\tR\x07tableId\
    \x12\x1a\n\x08headerId\x18\x02\x20\x01(\tR\x08headerId\"M\n\x08Response\
    \x12)\n\x06status\x18\x01\x20\x01(\x0e2\x11.tableflow.StatusR\x06status\
    \x12\x16\n\x06errMsg\x18\x02\x20\x01(\tR\x06errMsg\"\xd6\x01\n\rUpdateRe\
    quest\x127\n\x06action\x18\x01\x20\x01(\x0e2\x1f.tableflow.UpdateRequest\
    .ActionR\x06action\x12\x18\n\x07tableId\x18\x02\x20\x01(\tR\x07tableId\
    \x12\x1a\n\x08headerId\x18\x03\x20\x01(\tR\x08headerId\x12*\n\x07entries\
    \x18\x04\x20\x03(\x0b2\x10.tableflow.EntryR\x07entries\"*\n\x06Action\
    \x12\x0f\n\x0bUpdateEntry\x10\0\x12\x0f\n\x0bDeleteEntry\x10\x01\"\x9d\
    \x01\n\x0eUpdateResponse\x12)\n\x06status\x18\x01\x20\x01(\x0e2\x11.tabl\
    eflow.StatusR\x06status\x12\x16\n\x06errMsg\x18\x02\x20\x01(\tR\x06errMs\
    g\x12(\n\x0faffectedEntries\x18\x03\x20\x01(\rR\x0faffectedEntries\x12\
    \x1e\n\nlastRowIdx\x18\x04\x20\x01(\x04R\nlastRowIdx\"q\n\rInsertRequest\
    \x12\x18\n\x07tableId\x18\x01\x20\x01(\tR\x07tableId\x12\x1a\n\x08header\
    Id\x18\x02\x20\x01(\tR\x08headerId\x12*\n\x07entries\x18\x03\x20\x03(\
    \x0b2\x10.tableflow.EntryR\x07entries\"S\n\x0eInsertResponse\x12)\n\x06s\
    tatus\x18\x01\x20\x01(\x0e2\x11.tableflow.StatusR\x06status\x12\x16\n\
    \x06errMsg\x18\x02\x20\x01(\tR\x06errMsg*\"\n\x06Status\x12\x0b\n\x07Suc\
    cess\x10\0\x12\x0b\n\x07Failure\x10\x012\x87\x02\n\nDataEngine\x12<\n\
    \x05Query\x12\x17.tableflow.QueryRequest\x1a\x18.tableflow.QueryResponse\
    \"\0\x129\n\x06Delete\x12\x18.tableflow.DeleteRequest\x1a\x13.tableflow.\
    Response\"\0\x12?\n\x06Update\x12\x18.tableflow.UpdateRequest\x1a\x19.ta\
    bleflow.UpdateResponse\"\0\x12?\n\x06Insert\x12\x18.tableflow.InsertRequ\
    est\x1a\x19.tableflow.InsertResponse\"\02\xf0\x01\n\x0eMetadataEngine\
    \x120\n\x03Get\x12\x15.tableflow.TableQuery\x1a\x10.tableflow.Table\"\0\
    \x126\n\x06Delete\x12\x15.tableflow.TableQuery\x1a\x13.tableflow.Respons\
    e\"\0\x12A\n\x06Update\x12\x20.tableflow.UpdateMetadataRequest\x1a\x13.t\
    ableflow.Response\"\0\x121\n\x06Create\x12\x10.tableflow.Table\x1a\x13.t\
    ableflow.Response\"\0B\x11Z\x0ftableflow/typesJ\xf5\x1e\n\x06\x12\x04\0\
    \0}\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\0\
    \x12\n\x08\n\x01\x08\x12\x03\x03\0&\n\t\n\x02\x08\x0b\x12\x03\x03\0&\n\t\
    \n\x02\x03\0\x12\x03\x04\0&\n\t\n\x02\x03\x01\x12\x03\x05\0)\n\n\n\x02\
    \x06\0\x12\x04\x07\0\x0c\x01\n\n\n\x03\x06\0\x01\x12\x03\x07\x08\x12\n\
    \x0b\n\x04\x06\0\x02\0\x12\x03\x08\x024\n\x0c\n\x05\x06\0\x02\0\x01\x12\
    \x03\x08\x06\x0b\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x08\x0c\x18\n\x0c\n\
    \x05\x06\0\x02\0\x03\x12\x03\x08#0\n\x0b\n\x04\x06\0\x02\x01\x12\x03\t\
    \x021\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03\t\x06\x0c\n\x0c\n\x05\x06\0\
    \x02\x01\x02\x12\x03\t\r\x1a\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03\t%-\n\
    \x0b\n\x04\x06\0\x02\x02\x12\x03\n\x027\n\x0c\n\x05\x06\0\x02\x02\x01\
    \x12\x03\n\x06\x0c\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\n\r\x1a\n\x0c\n\
    \x05\x06\0\x02\x02\x03\x12\x03\n%3\n\x0b\n\x04\x06\0\x02\x03\x12\x03\x0b\
    \x027\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03\x0b\x06\x0c\n\x0c\n\x05\x06\
    \0\x02\x03\x02\x12\x03\x0b\r\x1a\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03\
    \x0b%3\n\n\n\x02\x06\x01\x12\x04\x0e\0\x13\x01\n\n\n\x03\x06\x01\x01\x12\
    \x03\x0e\x08\x16\n\x0b\n\x04\x06\x01\x02\0\x12\x03\x0f\x02(\n\x0c\n\x05\
    \x06\x01\x02\0\x01\x12\x03\x0f\x06\t\n\x0c\n\x05\x06\x01\x02\0\x02\x12\
    \x03\x0f\n\x14\n\x0c\n\x05\x06\x01\x02\0\x03\x12\x03\x0f\x1f$\n\x0b\n\
    \x04\x06\x01\x02\x01\x12\x03\x10\x02.\n\x0c\n\x05\x06\x01\x02\x01\x01\
    \x12\x03\x10\x06\x0c\n\x0c\n\x05\x06\x01\x02\x01\x02\x12\x03\x10\r\x17\n\
    \x0c\n\x05\x06\x01\x02\x01\x03\x12\x03\x10\"*\n\x0b\n\x04\x06\x01\x02\
    \x02\x12\x03\x11\x029\n\x0c\n\x05\x06\x01\x02\x02\x01\x12\x03\x11\x06\
    \x0c\n\x0c\n\x05\x06\x01\x02\x02\x02\x12\x03\x11\r\"\n\x0c\n\x05\x06\x01\
    \x02\x02\x03\x12\x03\x11-5\n\x0b\n\x04\x06\x01\x02\x03\x12\x03\x12\x02)\
    \n\x0c\n\x05\x06\x01\x02\x03\x01\x12\x03\x12\x06\x0c\n\x0c\n\x05\x06\x01\
    \x02\x03\x02\x12\x03\x12\r\x12\n\x0c\n\x05\x06\x01\x02\x03\x03\x12\x03\
    \x12\x1d%\n\n\n\x02\x04\0\x12\x04\x15\0\x17\x01\n\n\n\x03\x04\0\x01\x12\
    \x03\x15\x08\x12\n\x0b\n\x04\x04\0\x02\0\x12\x03\x16\x02\x15\n\x0c\n\x05\
    \x04\0\x02\0\x05\x12\x03\x16\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\
    \x16\t\x10\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x16\x13\x14\n\n\n\x02\x04\
    \x01\x12\x04\x19\01\x01\n\n\n\x03\x04\x01\x01\x12\x03\x19\x08\r\n\x0b\n\
    \x04\x04\x01\x02\0\x12\x03\x1a\x02\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\
    \x03\x1a\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x1a\t\x0b\n\x0c\n\
    \x05\x04\x01\x02\0\x03\x12\x03\x1a\x0e\x0f\n\x0b\n\x04\x04\x01\x02\x01\
    \x12\x03\x1b\x02\"\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03\x1b\x02\n\n\
    \x0c\n\x05\x04\x01\x02\x01\x06\x12\x03\x1b\x0b\x15\n\x0c\n\x05\x04\x01\
    \x02\x01\x01\x12\x03\x1b\x16\x1d\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\
    \x1b\x20!\n\x0b\n\x04\x04\x01\x02\x02\x12\x03\x1c\x02\x12\n\x0c\n\x05\
    \x04\x01\x02\x02\x05\x12\x03\x1c\x02\x08\n\x0c\n\x05\x04\x01\x02\x02\x01\
    \x12\x03\x1c\t\r\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\x1c\x10\x11\n\
    \x0b\n\x04\x04\x01\x02\x03\x12\x03\x1d\x02\x19\n\x0c\n\x05\x04\x01\x02\
    \x03\x05\x12\x03\x1d\x02\x08\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03\x1d\
    \t\x14\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03\x1d\x17\x18\n\x0b\n\x04\
    \x04\x01\x02\x04\x12\x03\x1e\x02\x12\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\
    \x03\x1e\x02\x08\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03\x1e\t\r\n\x0c\n\
    \x05\x04\x01\x02\x04\x03\x12\x03\x1e\x10\x11\n\x0b\n\x04\x04\x01\x02\x05\
    \x12\x03\x1f\x02(\n\x0c\n\x05\x04\x01\x02\x05\x06\x12\x03\x1f\x02\x1b\n\
    \x0c\n\x05\x04\x01\x02\x05\x01\x12\x03\x1f\x1c#\n\x0c\n\x05\x04\x01\x02\
    \x05\x03\x12\x03\x1f&'\n\x0b\n\x04\x04\x01\x02\x06\x12\x03\x20\x02)\n\
    \x0c\n\x05\x04\x01\x02\x06\x06\x12\x03\x20\x02\x1b\n\x0c\n\x05\x04\x01\
    \x02\x06\x01\x12\x03\x20\x1c$\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03\
    \x20'(\n\x0c\n\x04\x04\x01\x03\0\x12\x04\"\x02'\x03\n\x0c\n\x05\x04\x01\
    \x03\0\x01\x12\x03\"\n\x14\n\r\n\x06\x04\x01\x03\0\x02\0\x12\x03#\x04\
    \x12\n\x0e\n\x07\x04\x01\x03\0\x02\0\x05\x12\x03#\x04\n\n\x0e\n\x07\x04\
    \x01\x03\0\x02\0\x01\x12\x03#\x0b\r\n\x0e\n\x07\x04\x01\x03\0\x02\0\x03\
    \x12\x03#\x10\x11\n\r\n\x06\x04\x01\x03\0\x02\x01\x12\x03$\x04\x18\n\x0e\
    \n\x07\x04\x01\x03\0\x02\x01\x06\x12\x03$\x04\x0e\n\x0e\n\x07\x04\x01\
    \x03\0\x02\x01\x01\x12\x03$\x0f\x13\n\x0e\n\x07\x04\x01\x03\0\x02\x01\
    \x03\x12\x03$\x16\x17\n\r\n\x06\x04\x01\x03\0\x02\x02\x12\x03%\x04\x15\n\
    \x0e\n\x07\x04\x01\x03\0\x02\x02\x05\x12\x03%\x04\n\n\x0e\n\x07\x04\x01\
    \x03\0\x02\x02\x01\x12\x03%\x0b\x10\n\x0e\n\x07\x04\x01\x03\0\x02\x02\
    \x03\x12\x03%\x13\x14\n\r\n\x06\x04\x01\x03\0\x02\x03\x12\x03&\x04\x14\n\
    \x0e\n\x07\x04\x01\x03\0\x02\x03\x05\x12\x03&\x04\n\n\x0e\n\x07\x04\x01\
    \x03\0\x02\x03\x01\x12\x03&\x0b\x0f\n\x0e\n\x07\x04\x01\x03\0\x02\x03\
    \x03\x12\x03&\x12\x13\n\x0c\n\x04\x04\x01\x04\0\x12\x04)\x020\x03\n\x0c\
    \n\x05\x04\x01\x04\0\x01\x12\x03)\x07\x11\n\r\n\x06\x04\x01\x04\0\x02\0\
    \x12\x03*\x04\r\n\x0e\n\x07\x04\x01\x04\0\x02\0\x01\x12\x03*\x04\x08\n\
    \x0e\n\x07\x04\x01\x04\0\x02\0\x02\x12\x03*\x0b\x0c\n\r\n\x06\x04\x01\
    \x04\0\x02\x01\x12\x03+\x04\x10\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x01\
    \x12\x03+\x04\x0b\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x02\x12\x03+\x0e\x0f\
    \n\r\n\x06\x04\x01\x04\0\x02\x02\x12\x03,\x04\x0f\n\x0e\n\x07\x04\x01\
    \x04\0\x02\x02\x01\x12\x03,\x04\n\n\x0e\n\x07\x04\x01\x04\0\x02\x02\x02\
    \x12\x03,\r\x0e\n\r\n\x06\x04\x01\x04\0\x02\x03\x12\x03-\x04\r\n\x0e\n\
    \x07\x04\x01\x04\0\x02\x03\x01\x12\x03-\x04\x08\n\x0e\n\x07\x04\x01\x04\
    \0\x02\x03\x02\x12\x03-\x0b\x0c\n\r\n\x06\x04\x01\x04\0\x02\x04\x12\x03.\
    \x04\r\n\x0e\n\x07\x04\x01\x04\0\x02\x04\x01\x12\x03.\x04\x08\n\x0e\n\
    \x07\x04\x01\x04\0\x02\x04\x02\x12\x03.\x0b\x0c\n\r\n\x06\x04\x01\x04\0\
    \x02\x05\x12\x03/\x04\x10\n\x0e\n\x07\x04\x01\x04\0\x02\x05\x01\x12\x03/\
    \x04\x0b\n\x0e\n\x07\x04\x01\x04\0\x02\x05\x02\x12\x03/\x0e\x0f\n\n\n\
    \x02\x04\x02\x12\x043\06\x01\n\n\n\x03\x04\x02\x01\x12\x033\x08\x1d\n\
    \x0b\n\x04\x04\x02\x02\0\x12\x034\x02\x10\n\x0c\n\x05\x04\x02\x02\0\x05\
    \x12\x034\x02\x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x034\t\x0b\n\x0c\n\
    \x05\x04\x02\x02\0\x03\x12\x034\x0e\x0f\n\x0b\n\x04\x04\x02\x02\x01\x12\
    \x035\x02\x14\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\x035\x02\x07\n\x0c\n\
    \x05\x04\x02\x02\x01\x01\x12\x035\x08\x0f\n\x0c\n\x05\x04\x02\x02\x01\
    \x03\x12\x035\x12\x13\n\n\n\x02\x04\x03\x12\x048\0=\x01\n\n\n\x03\x04\
    \x03\x01\x12\x038\x08\x14\n\x0b\n\x04\x04\x03\x02\0\x12\x039\x02\x15\n\
    \x0c\n\x05\x04\x03\x02\0\x05\x12\x039\x02\x08\n\x0c\n\x05\x04\x03\x02\0\
    \x01\x12\x039\t\x10\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x039\x13\x14\n\x0b\
    \n\x04\x04\x03\x02\x01\x12\x03:\x02\x16\n\x0c\n\x05\x04\x03\x02\x01\x05\
    \x12\x03:\x02\x08\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03:\t\x11\n\x0c\n\
    \x05\x04\x03\x02\x01\x03\x12\x03:\x14\x15\n\x0b\n\x04\x04\x03\x02\x02\
    \x12\x03;\x02\x16\n\x0c\n\x05\x04\x03\x02\x02\x06\x12\x03;\x02\t\n\x0c\n\
    \x05\x04\x03\x02\x02\x01\x12\x03;\n\x11\n\x0c\n\x05\x04\x03\x02\x02\x03\
    \x12\x03;\x14\x15\n\x0b\n\x04\x04\x03\x02\x03\x12\x03<\x02#\n\x0c\n\x05\
    \x04\x03\x02\x03\x06\x12\x03<\x02\x18\n\x0c\n\x05\x04\x03\x02\x03\x01\
    \x12\x03<\x19\x1e\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03<!\"\n\n\n\x02\
    \x04\x04\x12\x04?\0H\x01\n\n\n\x03\x04\x04\x01\x12\x03?\x08\x0f\n\x0b\n\
    \x04\x04\x04\x02\0\x12\x03@\x02\x12\n\x0c\n\x05\x04\x04\x02\0\x05\x12\
    \x03@\x02\x08\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03@\t\r\n\x0c\n\x05\x04\
    \x04\x02\0\x03\x12\x03@\x10\x11\n\x0b\n\x04\x04\x04\x02\x01\x12\x03A\x02\
    \x13\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03A\x02\x08\n\x0c\n\x05\x04\
    \x04\x02\x01\x01\x12\x03A\t\x0e\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03A\
    \x11\x12\n\x0b\n\x04\x04\x04\x02\x02\x12\x03B\x02\x10\n\x0c\n\x05\x04\
    \x04\x02\x02\x06\x12\x03B\x02\x06\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\
    \x03B\x07\x0b\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03B\x0e\x0f\n\x0c\n\
    \x04\x04\x04\x04\0\x12\x04D\x02G\x03\n\x0c\n\x05\x04\x04\x04\0\x01\x12\
    \x03D\x07\x0b\n\r\n\x06\x04\x04\x04\0\x02\0\x12\x03E\x04\x0c\n\x0e\n\x07\
    \x04\x04\x04\0\x02\0\x01\x12\x03E\x04\x07\n\x0e\n\x07\x04\x04\x04\0\x02\
    \0\x02\x12\x03E\n\x0b\n\r\n\x06\x04\x04\x04\0\x02\x01\x12\x03F\x04\r\n\
    \x0e\n\x07\x04\x04\x04\0\x02\x01\x01\x12\x03F\x04\x08\n\x0e\n\x07\x04\
    \x04\x04\0\x02\x01\x02\x12\x03F\x0b\x0c\n\n\n\x02\x04\x05\x12\x04J\0M\
    \x01\n\n\n\x03\x04\x05\x01\x12\x03J\x08\x15\n\x0b\n\x04\x04\x05\x02\0\
    \x12\x03K\x02\x1f\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03K\x02\n\n\x0c\n\
    \x05\x04\x05\x02\0\x06\x12\x03K\x0b\x10\n\x0c\n\x05\x04\x05\x02\0\x01\
    \x12\x03K\x11\x1a\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03K\x1d\x1e\n\x0b\n\
    \x04\x04\x05\x02\x01\x12\x03L\x02\x14\n\x0c\n\x05\x04\x05\x02\x01\x06\
    \x12\x03L\x02\x08\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03L\t\x0f\n\x0c\n\
    \x05\x04\x05\x02\x01\x03\x12\x03L\x12\x13\n\n\n\x02\x05\0\x12\x04N\0Q\
    \x01\n\n\n\x03\x05\0\x01\x12\x03N\x05\x0b\n\x0b\n\x04\x05\0\x02\0\x12\
    \x03O\x02\x0e\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03O\x02\t\n\x0c\n\x05\x05\
    \0\x02\0\x02\x12\x03O\x0c\r\n\x0b\n\x04\x05\0\x02\x01\x12\x03P\x02\x0e\n\
    \x0c\n\x05\x05\0\x02\x01\x01\x12\x03P\x02\t\n\x0c\n\x05\x05\0\x02\x01\
    \x02\x12\x03P\x0c\r\n\n\n\x02\x04\x06\x12\x04R\0U\x01\n\n\n\x03\x04\x06\
    \x01\x12\x03R\x08\r\n\x0b\n\x04\x04\x06\x02\0\x12\x03S\x02\x14\n\x0c\n\
    \x05\x04\x06\x02\0\x05\x12\x03S\x02\x08\n\x0c\n\x05\x04\x06\x02\0\x01\
    \x12\x03S\t\x0f\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03S\x12\x13\n\x0b\n\
    \x04\x04\x06\x02\x01\x12\x03T\x02\x12\n\x0c\n\x05\x04\x06\x02\x01\x05\
    \x12\x03T\x02\x07\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03T\x08\r\n\x0c\n\
    \x05\x04\x06\x02\x01\x03\x12\x03T\x10\x11\n\n\n\x02\x04\x07\x12\x04W\0Z\
    \x01\n\n\n\x03\x04\x07\x01\x12\x03W\x08\x15\n\x0b\n\x04\x04\x07\x02\0\
    \x12\x03X\x02\x15\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03X\x02\x08\n\x0c\n\
    \x05\x04\x07\x02\0\x01\x12\x03X\t\x10\n\x0c\n\x05\x04\x07\x02\0\x03\x12\
    \x03X\x13\x14\n\x0b\n\x04\x04\x07\x02\x01\x12\x03Y\x02\x16\n\x0c\n\x05\
    \x04\x07\x02\x01\x05\x12\x03Y\x02\x08\n\x0c\n\x05\x04\x07\x02\x01\x01\
    \x12\x03Y\t\x11\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03Y\x14\x15\n\n\n\
    \x02\x04\x08\x12\x04\\\0_\x01\n\n\n\x03\x04\x08\x01\x12\x03\\\x08\x10\n\
    \x0b\n\x04\x04\x08\x02\0\x12\x03]\x02\x14\n\x0c\n\x05\x04\x08\x02\0\x06\
    \x12\x03]\x02\x08\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03]\t\x0f\n\x0c\n\
    \x05\x04\x08\x02\0\x03\x12\x03]\x12\x13\n\x0b\n\x04\x04\x08\x02\x01\x12\
    \x03^\x02\x14\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03^\x02\x08\n\x0c\n\
    \x05\x04\x08\x02\x01\x01\x12\x03^\t\x0f\n\x0c\n\x05\x04\x08\x02\x01\x03\
    \x12\x03^\x12\x13\n\n\n\x02\x04\t\x12\x04a\0k\x01\n\n\n\x03\x04\t\x01\
    \x12\x03a\x08\x15\n\x0b\n\x04\x04\t\x02\0\x12\x03b\x02\x14\n\x0c\n\x05\
    \x04\t\x02\0\x06\x12\x03b\x02\x08\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03b\t\
    \x0f\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03b\x12\x13\n\x0b\n\x04\x04\t\x02\
    \x01\x12\x03c\x02\x15\n\x0c\n\x05\x04\t\x02\x01\x05\x12\x03c\x02\x08\n\
    \x0c\n\x05\x04\t\x02\x01\x01\x12\x03c\t\x10\n\x0c\n\x05\x04\t\x02\x01\
    \x03\x12\x03c\x13\x14\n\x0b\n\x04\x04\t\x02\x02\x12\x03d\x02\x16\n\x0c\n\
    \x05\x04\t\x02\x02\x05\x12\x03d\x02\x08\n\x0c\n\x05\x04\t\x02\x02\x01\
    \x12\x03d\t\x11\n\x0c\n\x05\x04\t\x02\x02\x03\x12\x03d\x14\x15\n\x0b\n\
    \x04\x04\t\x02\x03\x12\x03e\x02\x1d\n\x0c\n\x05\x04\t\x02\x03\x04\x12\
    \x03e\x02\n\n\x0c\n\x05\x04\t\x02\x03\x06\x12\x03e\x0b\x10\n\x0c\n\x05\
    \x04\t\x02\x03\x01\x12\x03e\x11\x18\n\x0c\n\x05\x04\t\x02\x03\x03\x12\
    \x03e\x1b\x1c\n\x0c\n\x04\x04\t\x04\0\x12\x04g\x02j\x03\n\x0c\n\x05\x04\
    \t\x04\0\x01\x12\x03g\x07\r\n\r\n\x06\x04\t\x04\0\x02\0\x12\x03h\x04\x14\
    \n\x0e\n\x07\x04\t\x04\0\x02\0\x01\x12\x03h\x04\x0f\n\x0e\n\x07\x04\t\
    \x04\0\x02\0\x02\x12\x03h\x12\x13\n\r\n\x06\x04\t\x04\0\x02\x01\x12\x03i\
    \x04\x14\n\x0e\n\x07\x04\t\x04\0\x02\x01\x01\x12\x03i\x04\x0f\n\x0e\n\
    \x07\x04\t\x04\0\x02\x01\x02\x12\x03i\x12\x13\n\n\n\x02\x04\n\x12\x04m\0\
    r\x01\n\n\n\x03\x04\n\x01\x12\x03m\x08\x16\n\x0b\n\x04\x04\n\x02\0\x12\
    \x03n\x02\x14\n\x0c\n\x05\x04\n\x02\0\x06\x12\x03n\x02\x08\n\x0c\n\x05\
    \x04\n\x02\0\x01\x12\x03n\t\x0f\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03n\x12\
    \x13\n\x0b\n\x04\x04\n\x02\x01\x12\x03o\x02\x14\n\x0c\n\x05\x04\n\x02\
    \x01\x05\x12\x03o\x02\x08\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03o\t\x0f\n\
    \x0c\n\x05\x04\n\x02\x01\x03\x12\x03o\x12\x13\n\x0b\n\x04\x04\n\x02\x02\
    \x12\x03p\x02\x1d\n\x0c\n\x05\x04\n\x02\x02\x05\x12\x03p\x02\x08\n\x0c\n\
    \x05\x04\n\x02\x02\x01\x12\x03p\t\x18\n\x0c\n\x05\x04\n\x02\x02\x03\x12\
    \x03p\x1b\x1c\n\x0b\n\x04\x04\n\x02\x03\x12\x03q\x02\x18\n\x0c\n\x05\x04\
    \n\x02\x03\x05\x12\x03q\x02\x08\n\x0c\n\x05\x04\n\x02\x03\x01\x12\x03q\t\
    \x13\n\x0c\n\x05\x04\n\x02\x03\x03\x12\x03q\x16\x17\n\n\n\x02\x04\x0b\
    \x12\x04t\0x\x01\n\n\n\x03\x04\x0b\x01\x12\x03t\x08\x15\n\x0b\n\x04\x04\
    \x0b\x02\0\x12\x03u\x02\x15\n\x0c\n\x05\x04\x0b\x02\0\x05\x12\x03u\x02\
    \x08\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03u\t\x10\n\x0c\n\x05\x04\x0b\
    \x02\0\x03\x12\x03u\x13\x14\n\x0b\n\x04\x04\x0b\x02\x01\x12\x03v\x02\x16\
    \n\x0c\n\x05\x04\x0b\x02\x01\x05\x12\x03v\x02\x08\n\x0c\n\x05\x04\x0b\
    \x02\x01\x01\x12\x03v\t\x11\n\x0c\n\x05\x04\x0b\x02\x01\x03\x12\x03v\x14\
    \x15\n\x0b\n\x04\x04\x0b\x02\x02\x12\x03w\x02\x1d\n\x0c\n\x05\x04\x0b\
    \x02\x02\x04\x12\x03w\x02\n\n\x0c\n\x05\x04\x0b\x02\x02\x06\x12\x03w\x0b\
    \x10\n\x0c\n\x05\x04\x0b\x02\x02\x01\x12\x03w\x11\x18\n\x0c\n\x05\x04\
    \x0b\x02\x02\x03\x12\x03w\x1b\x1c\n\n\n\x02\x04\x0c\x12\x04z\0}\x01\n\n\
    \n\x03\x04\x0c\x01\x12\x03z\x08\x16\n\x0b\n\x04\x04\x0c\x02\0\x12\x03{\
    \x02\x14\n\x0c\n\x05\x04\x0c\x02\0\x06\x12\x03{\x02\x08\n\x0c\n\x05\x04\
    \x0c\x02\0\x01\x12\x03{\t\x0f\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\x03{\x12\
    \x13\n\x0b\n\x04\x04\x0c\x02\x01\x12\x03|\x02\x14\n\x0c\n\x05\x04\x0c\
    \x02\x01\x05\x12\x03|\x02\x08\n\x0c\n\x05\x04\x0c\x02\x01\x01\x12\x03|\t\
    \x0f\n\x0c\n\x05\x04\x0c\x02\x01\x03\x12\x03|\x12\x13b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
