syntax = "proto3";

package coordinator;
import "common/stream.proto";
import "common/common.proto";

option go_package = "lightflus/runtime/proto";

/// RPC Api for Coordinator
service CoordinatorApi {
  /// Attempt to deploy a new dataflow and create a JobManager.
  /// Unless bump into network problems, JobManager will be informed the status of the deployed dataflow asynchronously.
  rpc CreateDataflow(common.Dataflow) returns (CreateDataflowResponse) {}
  /// Attempt to terminate a dataflow
  /// Unless bump into network problems, JobManager will be informed the status of the deployed dataflow asynchronously.
  /// After the status is transitioned into TERMINATED, the JobManager will be removed from coordinator
  rpc TerminateDataflow(common.ResourceId) returns (TerminateDataflowResponse) {}
  /// Get the details of a dataflow.
  /// The details contains: each operator's status, metrics, basic information, checkpoint status, etc.
  rpc GetDataflow(GetDataflowRequest) returns (GetDataflowResponse) {}
  /// Receive ack
  rpc ReceiveAck(common.Ack) returns (common.Response) {}
  /// Report task info
  rpc ReportTaskInfo(TaskInfo) returns (common.Response) {}
  /// Receive heartbeat
  rpc ReceiveHeartbeat(common.Heartbeat) returns (common.Response) {}
}

message CreateDataflowResponse {
  common.DataflowStatus status = 1;
}

message TerminateDataflowResponse {
  common.DataflowStatus status = 1;
}

message GetDataflowRequest {
  common.ResourceId job_id = 1;
}

message GetDataflowResponse {
  common.DataflowStatus status = 1;
  common.Dataflow graph = 2;
}

message TaskInfo {
  common.ResourceId job_id = 1;
  map<uint32, ExecutorInfo> executors_info = 2;

  message ExecutorInfo {
    uint32 executor_id = 1;
    ExecutorStatus status = 2;
  }

  enum ExecutorStatus {
    EXECUTOR_STATUS_INITIALIZED = 0;
    EXECUTOR_STATUS_RUNNING = 1;
    EXECUTOR_STATUS_TERMINATING = 2;
    EXECUTOR_STATUS_TERMINATED = 3;
  }
}